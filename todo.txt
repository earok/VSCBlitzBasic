   "Sound": {
      "prefix": "Sound",
      "body": "Sound Sound#,Channelmask[, Vol1[, Vol2...]",
      "description": "Sound causes a previously created sound object to be played through the Amiga's audio hardware. Channelmask specifies which of the Amiga's four audio channels the sound should be played through, and should be in the range one through fifhteen. The following is a list of Channelmask values and their effect: Mask   Channel0 Channel1   Channel2    Channel3 1 on   off off off 2 off   on off off 3 on   on off off 4 off   off on off 5 on   off on off 6 off   on on off 7 on   on on off 8 off   off off on 9 on   off off on 10 off   on off on 11 on   on off on 12 off   off on on 13 on   off on o 14 off   on on on 15 on   on on on In the above table, any audio channels specified as 'off' are not altered by Sound, and any sounds they may have previously been playing will not be affected. The Volx parameters allow individual volume settings for different audio channels. Volume settings must be in the range zero through 64, zero being silence, and 64 being loudest. The first Vol parameter specifies the volume for the lowest numbered 'on' audio channel, the second Vol for the next lowest and so on. For example, assume you are using the following Sound command: Sound 0,10,32,16 The Channelmask of ten means the sound will play through audio channels one and three. The first volume of 32 will be applied to channel one, and the second volume of 16 will be applied to channel three. Any Vol parameters omitted will be cause a volume setting of 64. ",
   },
   "LoopSound": {
      "prefix": "LoopSound",
      "body": "LoopSound Sound#,Channelmask[, Vol1[, Vol2...]",
      "description": "LoopSound behaves identically to Sound, only the sound will be played repeatedly. Looping a sound allows for the facility to play the entire sound just once, and begin repeating at a point in the sound other than the beginning. This information is picked up from the 8SVX IFF file, when LoadSound is used to create the sound, or from the offset parameter of InitSound. ",
   },
   "Volume": {
      "prefix": "Volume",
      "body": "Volume Channelmask, Vol1[, Vol2...]",
      "description": "Volume allowsyou to dynamically alter the volume of an audio channel. This enables effects such as volume fades. For an explanation of Channelmask and Vol parameters, please refer to the Sound command. ",
   },
   "InitSound": {
      "prefix": "InitSound",
      "body": "InitSound Sound#,LengthLPeriod[, Repeat]",
      "description": "InitSound initializes a sound object in preparation for the creation of custom sound data. This allows simple sound waves such as sine or square waves to be algorithmically created. SoundData should be used to create the actual wave data. ",
   },
   "Length": {
      "prefix": "Length",
      "body": "Length refers to the length, in bytes, the sound object is required to be.",
      "description": "Length MUST be less than 128K, and MUST be even. Period allows you to specify a default pitch for the sound. A period of 428 will cause the sound to be played at approximately middle 'C'. Otfset is used in conjunction with LoopSound, and specifies a position in the sound at which repeating should begin. Please refer to LoopSound for more information on repeating sounds ",
   },
   "SoundData": {
      "prefix": "SoundData",
      "body": "SoundData Sound#,Offset,Data",
      "description": "SoundData allows you to manually specify the waveform of a sound object. The sound object should normally have been created using InitSound, although altering IFF sounds is perfectly legal. SoundData alters one byte of sound data at the specified Offset. Data refers to the actual byte to place into the sound, and should be in the range -128 to +127. ",
   },
   "PeekSound": {
      "prefix": "PeekSound",
      "body": "PeekSound (Sound#,Offset)",
      "description": "PeekSound returns the byte of a sample at specified offset of sound object specified. ",
   },
   "DecodeSound": {
      "prefix": "DecodeSound",
      "body": "DecodeSound Sound#,MemoryLocation",
      "description": "DecodeSound, similar to the other new Decode commands allows the programmer to include sound files within their program's object code. SetPeriod Sound#,Period This command allows the programmer to manually adjust the period of the sound object to change it's effective pitch. ",
   },
   "DiskPlay": {
      "prefix": "DiskPlay",
      "body": "DiskPlay Filename$, Channelmask[, Vol1[, Vol2...]",
      "description": "DiskPlay will play an 8SVX IFF sound file straight from disk. This is ideal for situations where you simply want to play a sample without the extra hassle of loading a sound, playing it, and then freeing it. The DiskPlay command will also halt program flow until the sample has finished playing. DiskPlay usually requires much less memory to play a sample than the LoadSound, Sound technique. Also, DiskPlay allows you to play samples of any length, whereas LoadSound only allows samples up to 128K in length to be loaded. ",
   },
   "DiskBuffer": {
      "prefix": "DiskBuffer",
      "body": "DiskBuffer Bufferlen",
      "description": "DiskBuffer allows you to set the size of the memory buffer used by the DiskPlay command. This Buffer is by default set to 1024 bytes, and should not normally have to be set to more than this. Reducing the buffer size by too much may cause loss of sound quality of the DiskPlay command. If you are using DiskPlay to access a very slow device, the buffer size may have to be increased. ",
   },
   "Filter": {
      "prefix": "Filter",
      "body": "Filter On l Off",
      "description": "Filter may be used to turn on or off the Amiga's low pass audio filter. ",
   },
   "LoadModule": {
      "prefix": "LoadModule",
      "body": "LoadModule Module#,Filename$",
      "description": "LoadModule loads in from disk a soundtracker/noisetracker music module This module may be later played back using PlayModule. ",
   },
   "Free": {
      "prefix": "Free",
      "body": "Free Module Module#",
      "description": "Free Module may be used to delete a module object. Any memory occupied by the module will also be free'd. ",
   },
   "PlayModule": {
      "prefix": "PlayModule",
      "body": "PlayModule Module#",
      "description": "PlayModule will cause a previously loaded soundtracker/noisetracker song module to be played back. ",
   },
   "StopModule": {
      "prefix": "StopModule",
      "body": "StopModule",
      "description": "StopModule will cause any soundtracker/noisetracker modules which may be currently playing to stop. ",
   },
   "Load": {
      "prefix": "Load",
      "body": "Load Med Module MedModule# Name",
      "description": "The LoadMedModule command loads any version 4 channel Octamed module. Following routines support up to and including version 3 of the Amiganut's Med standard. The number of MedModules loaded in memory at one time is only limited by the MedModules maximum set in the Blitz Options requester. Like any Blitz commands that access files LoadMedModule can only be used in AmigaMode. ",
   },
   "StartMedModule": {
      "prefix": "StartMedModule",
      "body": "StartMedModule MedModule#",
      "description": "StartMedModule is responsible for initialising the module including linking after it is loaded from disk using the LoadMedModule command. It can also be used to restart a module from the beginning. ",
   },
   "PlayMed": {
      "prefix": "PlayMed",
      "body": "PlayMed",
      "description": "PlayMed is responsible for playing the current MedModule, it must be called every 50th of a second either on an interupt (#5) or after a VWait in a program loop. ",
   },
   "StopMed": {
      "prefix": "StopMed",
      "body": "StopMed",
      "description": "StopMed will cause any med module to stop playing. This not only means that PlayMed will have no affect until the next StartMedModule but silences audio channels so they are not left ringing as is the effect when PlayMed is not called every vertical blank. ",
   },
   "JumpMed": {
      "prefix": "JumpMed",
      "body": "JumpMed Pattern#",
      "description": "JumpMed will change the pattern being played in the current module. ",
   },
   "SetMedVolume": {
      "prefix": "SetMedVolume",
      "body": "SetMedVolume Volume",
      "description": "SetMedVolume changes the overall volume that the Med Library plays the module, all the audio channels are affected. This is most useful for fading out music by slowly decreasing the volume from 64 to 0 ",
   },
   "GetMedVolume": {
      "prefix": "GetMedVolume",
      "body": "GetMedVolume Channel#",
      "description": "GetMedVolume returns the current volume setting of the specified audio channel. This is useful for graphic effects required to sync to certain channels of the music playing. ",
   },
   "GetMedNote": {
      "prefix": "GetMedNote",
      "body": "GetMedNote Channel#",
      "description": "GetMedNote returns the current note playing from the specified channel. As with GetMedVolume this is useful for producing graphics effects synced to the music the Med Library is playing. ",
   },
   "GetMedinstr": {
      "prefix": "GetMedinstr",
      "body": "GetMedinstr Channel",
      "description": "GetMedInstr returns the current instrument playing through the specified audio channel. ",
   },
   "SetMedMask": {
      "prefix": "SetMedMask",
      "body": "SetMedMask Channel Mask",
      "description": "SetMedMask allows the user to mask out audio channels needed by sound effects stopping the Med Library using them. ",
   },
   "DecodeMedModule": {
      "prefix": "DecodeMedModule",
      "body": "DecodeMedModule MedModule#,MemoryLocation",
      "description": "DecodeMedModule replaces the cludgemedmodule, as med modules are not packed but used raw, DecodeMedModule simply checks to see the memory location passed is in ChipMem (if not it copies the data to chip) and points the Blitz MedModule object to that memory. . Speak string$ The Speak command will first convert the given string to phonetics and then pass it to the Narrator.Device. Depending on the settings of the Narrator device (see SetVoice) the Amiga will \"speak\" the string you have sent in the familiar Amiga synthetic voice. ",
   },
   "SetVoice": {
      "prefix": "SetVoice",
      "body": "SetVoice rate,pitch,expression,sex, volume,frequency",
      "description": "SetVoice alters the sound of the Amiga's speech synthsiser by changing the vocal characteristics listed in the parameters above. ",
   },
   "Translate$": {
      "prefix": "Translate$",
      "body": "Translate$ (string$)",
      "description": "Translate$() returns the phonetic equivalent of the string for use with the ",
   },
   "PhoneticSpeak": {
      "prefix": "PhoneticSpeak",
      "body": "PhoneticSpeak command.",
      "description": "",
   },
   "PhoneticSpeak": {
      "prefix": "PhoneticSpeak",
      "body": "PhoneticSpeak phonetic$",
      "description": "PhoneticSpeak is similar to the Speak command but should only be passed strings containing legal phonemes such as that produced by the Translate$() function. ",
   },
   "VoiceLoc": {
      "prefix": "VoiceLoc",
      "body": "VoiceLoc",
      "description": "VoiceLoc returns a pointer to the internal variables in the speech synthesiser that enable the user to access new parameters added to the V37 Narrator Device. Formants as referred to in the descriptions are the major vocal tracts and are separated into the parts of speech that produce the bass, medium and trebly sounds. Screen Screen#,Mode[,  Title$] Screen#,X, Y, Width,Height,Depth, VMode,Title$,Dpen,Bpen[BMap#] Screen will open an Intuition screen. The are 2 formats of the screen command, a ",
   },
   "quick": {
      "prefix": "quick",
      "body": "quick format, and a long format.",
      "description": "The quick format of the Screen commands involves 3 parameters - Screen#, Mode and an optional Title$. Screen# specifies the screen object to create. Mode specifies how many bitplanes the screen is to have, and should be in the range 1 through 6. Adding 8 to Mode will cause a hi-res screen to be opened, as opposed to the default lo-res screen. A hi-res screen may only have from 1 to 4 bitplanes. Adding 16 to Mode will cause an interlaced screen to be opened. Title$ allows you to add a title to the screen. The long format of Screen gives you much more control over how the screen is opened. The VMode parameter refers to the resolution of the Screen, add the values together to make up the screenmode you require: hires =$8000 ham =$200 superhires =$20 interlace  =4 lores =0 ",
   },
   "ShowScreen": {
      "prefix": "ShowScreen",
      "body": "ShowScreen Screen#",
      "description": "ShowScreen will cause the specified screen object to be moved to front of the display. ",
   },
   "WbToScreen": {
      "prefix": "WbToScreen",
      "body": "WbToScreen Screen#",
      "description": "WbToScreen will assign the Workbench screen a screen object number. This allows you to perform any of the functions that you would normally do own your own screens, on the Workbench screen. It's main usage is to allow you to open windows on the Workbench screen. After execution, the Workbench screen will become the currently used screen. FindScreen Screen#[, Title$] This command will find a screen and give it an object number so it can be referenced in your programs. If Title$ is not specified, then the foremost screen is found and given the object number Screen#. If the Title$ argument is specified, then a screen will be searched for that has this name. After execution, the found screen will automatically become the currently used screen. ",
   },
   "LoadScreen": {
      "prefix": "LoadScreen",
      "body": "LoadScreen Screen#, Filename$[, Palette#]",
      "description": "LoadScreen loads an IFF ILBM picture into the screen object specified by Screen#. The file that is loaded is specified by Filename$. You can also choose to load in the colour palette for the screen, by specifying the optional Palette#. This value is the object number of the palette you want the pictures colours to be loaded into. For the colours to be used on your screen, you will have to use the statement. ",
   },
   "SaveScreen": {
      "prefix": "SaveScreen",
      "body": "SaveScreen Screen#,Filename$",
      "description": "SaveScreen will save a screen to disk as an IFF ILBM file. The screen you wish to save is specified by the Screen#, and the name of the file you to create is specified by Filename$. ",
   },
   "SMouseX": {
      "prefix": "SMouseX",
      "body": "SMouseX",
      "description": "SMouseX returns the horizontal position of the mouse relative to the left edge of the currently used screen. ",
   },
   "SMouseY": {
      "prefix": "SMouseY",
      "body": "SMouseY",
      "description": "SMouseY returns vertical position of the mouse relative to top of the current screen. ViewPort (Screen#) The ViewPort function returns the location of the specified screens ViewPort. The ViewPort address can be used with graphics.library commands and the like. ",
   },
   "ScreenPens": {
      "prefix": "ScreenPens",
      "body": "ScreenPens active text,inactive text,hilight,shadow,active fill,gadget fill",
      "description": "ScreenPens configures the 10 default pens used for system gadgets in WB 2. Any Screens opened after a ScreenPens statement will use the pens defined. This command will have no affect when used with Workbench 1.3 or earlier ",
   },
   "CloseScreen": {
      "prefix": "CloseScreen",
      "body": "CloseScreen Screen#",
      "description": "CloseScreen has been added for convenience. Same as Free Screen but a little more intuitive (especially for those that have complained about such matters (yes we care)). HideScreen Screen# Move Screen to back of all Screens open in the system. BeepScreen Screen# Flash specified screen. MoveScreen Screen#,deltax,deltay Move specified screen by specified amount. Good for system friendly special effects. ScreenTags Screen#,Title$[&TagList]or[[,Tag,Data]...] Full access to all the Amiga's new display resoutions is now available in Amiga mode by use of ScreenTags command. Following tags are of most interest to programmers. #Left=$80000021 : #Top=$80000022 : #Width=$80000023 #Height=$80000024 : #Depth=$80000025 : #DetailPen=$80000026 #BlockPen=$80000027 #Title=$80000028 : #Colors=$80000029 : #ErrorCode=$8000002A #Font=$8000002B : #SysFont=$8000002C : #Type=$8000002D #BitMap=$8000002E #PubName=$8000002F : #PubSig=$80000030 #PubTask=$80000031 : #DisplayID=$80000032 #DClip=$80000033 : #0verscan=$80000034 #ShowTitle=$80000036 : #Behind=$80000037 : #Quiet=$80000038 #AutoScroll=$80000039 : #Pens=$8000003A #FullPalette=$8000003B : #ColorMapEntries=$8000003C #Parent=$8000003D : #Draggable=$8000003E #Exclusive=$8000003F #SharePens=$80000040 : #BackFill=$80000041 #Interleaved=$80000042 #Colors32=$80000043 : #VideoControl=$80000044 #FrontChild=$80000045 : #BackChild=$80000046 #LikeWorkbench=$80000047 : #Reserved=$80000048 ",
   },
   "ShowBitMap": {
      "prefix": "ShowBitMap",
      "body": "ShowBitMap [BitMap#]",
      "description": "The ShowBitMap command is the Amiga-mode version of the Show command. It enables you to change a Screens bitmap allowing double buffered (flicker free) animation to happen on a standard Intuition Screen. Unlike Blitz mode it is better to do ShowBitMap then VWait to sync up with the Amiga's display, this will make sure the new bitmap is being displayed before modifying the previous BitMap Window Window#,X, Y, Width, Height, Flags, Title$, Dpen, Spen[,GadgetList#] Window opens an Intuition window on the currently used screen. Window# is a unique object number for the new window. X & Y refer to the offset from top left of the screen the window is to appear at. Width and Height are the size of the window in pixels. Flags are the special window flags that a window can have when opened. These flags allow for the inclusion of a sizing gadget, dragbar and many other things. The flags are listed as followed, with their corresponding values. To select more than one of these flags, they must be logically Or'd together using the 'l ' operator. For example, to open a window with dragbar and sizing gadget which is active once opened, you would specify a Flags parameter of $1 I $2 I $1000. Title$ is a BASIC string, either a constant or a variable, that you want to be the title of the window. Dpen is the colour of the detail pen of the window. This colour is used for window title. BPen is the block pen of the window. This pen is used for things like the border around the edge of the window. The optional GadgetList# is the number of a gadgetlist object you have may want attached to the window After the window has opened, it will become the currently used window. The Window library has been extended to handle super bitmap windows. SuperBitMap windows allow the window to have it's own bitmap which can actually be larger than the window. The two main benefits of this feature are the window's ability to refresh itself and the ability to scroll around a large area \"inside\" the bitmap. To attach a BitMap to a Window set the SuperBitMap flag in the flags field and include the BitMap# to be attached. ",
   },
   "Window": {
      "prefix": "Window",
      "body": "Window Flag    Value Description",
      "description": "WINDOWSIZING  $0001 Attaches sizing gadget to bottom right corner of window and allows it to be sized. WINDOWDRAG   $0002 Allows window to be dragged with the mouse by it's title bar. WINDOWDEPTH  $0004 Lets windows be pushed behind or in front of other windows. WINDOWCLOSE  $0008 Attaches a closegadget to the upper left corner of the window. SIZEBRIGHT    $0010 With GIMMEZERO & ZEROWINDOWSIZING set, this will leave the right hand margin, the width of the sizing gadget, clear, and drawing in window will not extend over this right margin. SIZEBBOTTOM  $0020 Same as SIZEBRIGHT except it leaves a margin at the bottom of the window, the width of the sizing gadget. BACKDROP    $0100 This opens the window behind any other window that is already opened. It cannot have the WINDOWDEPTH flag set also, as the window is intended to stay behind all others. GIMME00    $0400 This flag keeps the windows border separate from the rest of the windows area. Any drawing on the window, extending to the borders, will not overwrite the border. NOTE: Although convevient, this does take up more memory than usual. BORDERLESS   $0800 Opens a window without any border on it at all. ACTIVATE    $1000 Activates the window once opened. ",
   },
   "Use": {
      "prefix": "Use",
      "body": "Use Window Window#",
      "description": "Use Window will cause the specified window object to become the currently used window. Use Window also automatically performs a WindowInput and WindowOutput on the specified window. ",
   },
   "Free": {
      "prefix": "Free",
      "body": "Free Window Window#",
      "description": "Free Window closes down a window. This window is now gone, and can not be accessed any more by any statements or functions. Once a window is closed, you may want to direct the input and output somewhere new, by calling Use Window on another window, DefaultOutput/DefaultInput, or by some other appropriate means. Window# is the window object number to close ",
   },
   "WindowInput": {
      "prefix": "WindowInput",
      "body": "WindowInput Window#",
      "description": "Windowinput will cause any future executions of the Inkey$, Edit$ or Edit functions to receive their input as keystrokes from the specified window object. WindowInput is automatically executed when either a window is opened, or Use Window is executed. After a window is closed (using Free Window), remember to tell Blitz to get it's input from somewhere else useful (for example, using another WindowInput command) before executing another Inkey$, Edit$ or Edit function. ",
   },
   "WindowOutput": {
      "prefix": "WindowOutput",
      "body": "WindowOutput Window#",
      "description": "WindowOutput will cause any future executions of either the Print or NPrint statements to send their output as text to the specified window object. WindowOutput is automatically executed when either a window is opened, or Use Window is executed. After a window is closed (using Free Window), remember to send output somewhere else useful (for example, using another WindowOutput command) before executing another Print or NPrint statement. DefaultlDCMP IDCMP_Flags DefaultIDCMP allows you to set the IDCMP flags used when opening further windows. You can change the flags as often as you like, causing all of your windows to have their own set of IDCMP flags if you wish. A window's IDCMP flags will affect the types of 'events' reportable by the window. Events are reported to a program by means of either the WaitEvent or Event functions. To select more than one IDCMP Flag when using DefaultIDCMP , combine the separate flags together using the OR operator ('I'). Any windows opened before any DefaultIDCMP command is executed will be opened using an IDCMP flags setting of: $2 I $4 I $8 I $20 I $40 I $100 I $200 I $400 I $40000 I $80000. This should be sufficient for most programs. If you do use DefaultIDCMP for some reason, it is important to remember to include all flags necessary for the functioning of the program. For example, if you open a window which is to have menus attached to it, you MUST set the $100 (menu selected) IDCMP flag, or else you will have no way of telling when a menu has been selected IDCMP FlagEvent $2 Reported when a window has it's size changed. $4 Reported when a windows contents have been corrupted. This may mean a windows contents may need to be re-drawn. $8 Reported when either mouse button has been hit. $10 Reported when the mouse has been moved. $20 Reported when a gadget within a window has been pushed 'down'. $40 Reported when a gadget within a window has been 'released'. $100 Reported when a menu operation within a window has occured. $200 Reported when the 'close' gadget of a window has been selected. $400 Reported when a keypress has been detected. $8000 Reported when a disk is inserted into a disk drive. $10000 Reported when a disk is removed from a disk drive. $40000 Reported when a window has been 'activated'. $80000 Reported when a window has been 'de-activated'. AddlDCMP IDCMP_Flags AddIDCMP allows you to 'add in' IDCMP flags to the IDCMP flags selected by DefaultIDCMP . Please refer to DefaultIDCMP for a thorough discussion of IDCMP flags. SublDCMP IDCMP_Flags SubIDCMP allows you to 'subtract out' IDCMP flags from the IDCMP flags selected by DefaultIDCMP . Please refer to DefaultIDCMP for a thorough discussion of IDCMP flags. ",
   },
   "WaitEvent": {
      "prefix": "WaitEvent",
      "body": "WaitEvent",
      "description": "WaitEvent will halt program excution until an Intuition event has been received. This event must be one that satisfies the IDCMP flags of any open windows. If used as a function, WaitEvent returns the IDCMP flag of the event (please refer to DefaultIDCMP for a table of possible IDCMP flags). If used as a statement, you have no way of telling what event occured. You may find the window object number that caused the event using the EventWindow function. In the case of events concerning gadgets or menus, further functions are available to detect which gadget or menu was played with. In the case of mouse button events, the MButtons function may be used to discover exactly which mouse button has been hit IMPORTANT NOTE: If you are assigning the result of WaitEvent to a variable, MAKE SURE that the variable is a long type variable. For example: MyEvent.l=WaitEvent ",
   },
   "Event": {
      "prefix": "Event",
      "body": "Event",
      "description": "Event works similarly to WaitEvent in that it returns the IDCMP flag of any outstanding windows events. However, Event will NOT cause program flow to halt. Instead, if no ",
   },
   "event": {
      "prefix": "event",
      "body": "event has occured, Event will return 0.",
      "description": "",
   },
   "EventWindow": {
      "prefix": "EventWindow",
      "body": "EventWindow",
      "description": "EventWindow is used to determine in which window the most recent window event occured. Window events are detected by use of either WaitEvent or Event commands. EventWindow returns the window object number in which the most recent window event occured Flush Events [IDCMP_Flag] When window events occur in Blitz, they are automatically 'queued' for you. This means that if your program is tied up processing one window event while others are being created, you wont miss out on anything. Any events which may have occured between executions of WaitEvent or Event will be stored in a queue for later use. There may be situations where you want to ignore this backlog of events.Use FlushEvents to make it. Executing FlushEvents with no parameters will completely clear Blitz's internal event queue, leaving you with no outstanding events. Supplying an IDCMP_Flag parameter will only clear events of the specified type from the event queue. ",
   },
   "GadgetHit": {
      "prefix": "GadgetHit",
      "body": "GadgetHit",
      "description": "GadgetHit returns the identification number of the gadget that caused the most recent 'gadget pushed' or 'gadget released' event. As gadgets in different windows may possibly posess the same identification numbers, you may also need to use EventWindow to tell exactly which gadget was hit. ",
   },
   "MenuHit": {
      "prefix": "MenuHit",
      "body": "MenuHit",
      "description": "MenuHit returns the identification number of the menu that caused the last menu event. As with gadgets, you can have different menus for different windows with same identification number. Therefore you may also need to use EventWindow to find which window caused the event. If no menus have yet been selected, Menuhit will return -1. ",
   },
   "ItemHit": {
      "prefix": "ItemHit",
      "body": "ItemHit",
      "description": "ItemHit returns the identification nr. of the menu item that caused the last menu event. ",
   },
   "SubHi": {
      "prefix": "SubHi",
      "body": "SubHi",
      "description": "SubHit returns the identification number of the the menu subitem that caused the last menu event. If no subitem was selected, SubHit will return -1. ",
   },
   "MButtons": {
      "prefix": "MButtons",
      "body": "MButtons",
      "description": "MButtons returns the codes for the mouse buttons that caused the most recent 'mouse buttons' event. If menus have been turned off using Menus Off, then the right mouse button will also register an event and can be read with MButtons. ",
   },
   "RawKey": {
      "prefix": "RawKey",
      "body": "RawKey",
      "description": "RawKey returns the raw key code of a key that caused most recent 'key press' evens. ",
   },
   "Qualifier": {
      "prefix": "Qualifier",
      "body": "Qualifier",
      "description": "Qualifier will return the qualifier of the last key that caused a 'key press' event to occur. A qualifier is a key which alters the meaning of other keys; for example the 'shift' keys. Here is a table of qualifier values and their equivalent keys: Key Left Right UnQualified $8000 $8000 Shift $8001 $8002 Caps Lock Down $8004 $8004 Control $8008 $8008 Alternate $8010 $8020 Amiga $8040 $8080 A combination of values may occur, if more that one qualifier key is being held down. The way to filter out the qualifiers that you want is by using the logical AND operator. ",
   },
   "WPlot": {
      "prefix": "WPlot",
      "body": "WPlot X,Y,Colour",
      "description": "WPlot plots a pixel in the currently used window at the coordinates X,Y in the colour specified by Colour. ",
   },
   "WBox": {
      "prefix": "WBox",
      "body": "WBox X1,Y1,X2,Y2,Colour",
      "description": "WBox draws a solid rectangle in the currently used window. The upper left hand coordinates of the box are specified with the X1 and Y1 values, and the bottom right hand corner of the box is specified by the values X2 and Y2. ",
   },
   "WCircle": {
      "prefix": "WCircle",
      "body": "WCircle X,Y,Radius,Colour",
      "description": "WCircle allows to draw a circle in currently used window. You specify the centre of the circle with the coordinates X,Y . The Radius value specifies the radius of the circle you want to draw. The last value, Colour specifies what colour the circle will be drawn in. ",
   },
   "WEllipse": {
      "prefix": "WEllipse",
      "body": "WEllipse X,Y,X Radius,Y Radius,Colour",
      "description": "WEllipse draws an ellipse in the currently used window. You specify the centre of the ellipse with the coordinates X,Y . X Radius specifies the horizontal radius of the ellipse, Y Radius the vertical radius. Colour refers to the colour in which to draw the ellipse. ",
   },
   "WLine": {
      "prefix": "WLine",
      "body": "WLine X1,Y1,X2,Y2[,Xn, Yn..],Colour",
      "description": "Wline allows you to draw a line or a series of lines into the currently used window. The first two sets of coordinates X1,Y1,X2,Y2, specify the start and end points of the initial line. Any coordinates specified after these initial two, will be the end points of another line going from the last set of end points, to this set. Colour is the colour of the line(s) that are to be drawn. ",
   },
   "WCls": {
      "prefix": "WCls",
      "body": "WCls [Colour]",
      "description": "WCls will clear the currently used window to colour 0, or a colour is specified, then it will be cleared to this colour. If the current window was not opened with the GIMMEZEROZERO flag set, then this statement will clear any border or title bar that the window has. The InnerCls statement should be used to avoid these side effects.. ",
   },
   "InnerCls": {
      "prefix": "InnerCls",
      "body": "InnerCls [Colour]",
      "description": "InnerCls will clear only the inner portion of the currently used window. It will not clear the titlebar or borders as WCls would do if your window was not opened with the GIMMEZEROZERO flag set. If a colour is specified, then that colour will be used to clear the window. ",
   },
   "WScroll": {
      "prefix": "WScroll",
      "body": "WScroll X1,Y1,X2,Y2,Delta X,Delta Y",
      "description": "WScroll will cause a rectangular area of the currently used window to be moved or 'scrolled'. X1 and Y1 specify the top left location of the rectangle, X2 and Y2 the bottom right. The Delta parameters determine how far to move the area. Positive values move the area right/down, while negative values move the area left/up. ",
   },
   "Cursor": {
      "prefix": "Cursor",
      "body": "Cursor Thickness",
      "description": "Cursor will set the style of cursor that appears when editing strings or numbers with the Edit$ or Edit functions. If Thickness is less than 0, then a block cursor will be used. If the Thickness is greater then 0, then an underline Thickness pixels high will be used. Editat After executing an Edit$ or Edit function, Editat may be used to determine the horizontal character position of the cursor at the time the function was exited. Through the use of Editat, EditExit, EditFrom and Edit$, simple full screen editors may be put together. ",
   },
   "EditFrom": {
      "prefix": "EditFrom",
      "body": "EditFrom [Characterpos]",
      "description": "EditFrom allows you to control how the Edit$ and Edit functions operate when used within windows If a Characterpos parameter is specified, then the next time an edit function is executed, editing will commence at the specified character position (0 being the first character position). Also, editing may be terminated by the use of the 'return' key or also by any non printable character ('up arrow' or 'Esc') or a window event. When used in conjunction with Editat and EditExit, this allows you to put together simple full screen editors. If Characterpos is omitted, Edit$ and Edit return to normal - editing always beginning at character postition 0, and 'return' being the only way to exit. ",
   },
   "EditExit": {
      "prefix": "EditExit",
      "body": "EditExit",
      "description": "EditExit returns the ASCII value of the character that was used to exit a window based Edit$ or Edit function. You can only exit the edit functions with keypresses other than 'return' if EditFrom has been executed prior to the edit call. ",
   },
   "WindowFont": {
      "prefix": "WindowFont",
      "body": "WindowFont IntuiFont#",
      "description": "WindowFont sets the font for the currently used window. Any further printing to this window will be in the specified font. IntuiFont# specifies a previously initialized intuifont object created using LoadFont. ",
   },
   "WColour": {
      "prefix": "WColour",
      "body": "WColour Foreground Colour[,Background Colour]",
      "description": "WColour sets the foreground and background colour of printed text for the currently used window. Any further text printed on this window will be in these colours. ",
   },
   "WJam": {
      "prefix": "WJam",
      "body": "WJam Jammode",
      "description": "WJam sets the text drawing mode of the currently used window. These drawing modes allow you to do inverted, complemented and other types of graphics. The drawing modes can be OR'ed together to create a combination of them. Jam1=0 This draws only the foreground colour and leaves the background transparent. Eg For the letter 0, any empty space (inside and outside the letter) will be transparent. Jam2=1 This draws both the foreground and background to the window. Eg With the letter 0 again, the 0 will be drawn, but any clear area (inside and outside) will be drawn in the current background colour. Complement=2 This will exlusive or (XOR) the bits of the graphics. Eg Drawing on the same place with the same graphics will cause the original display to return. Inversvid = This allows the display of inverse video characters. If used in conjunction with Jam2, it behaves like Jam2, but the foreground and background colours are exchanged. ",
   },
   "Activate": {
      "prefix": "Activate",
      "body": "Activate Window#",
      "description": "Activate will activate the window specified by Window#. ",
   },
   "Menus": {
      "prefix": "Menus",
      "body": "Menus On l Off",
      "description": "The Menus command may be used to turn ALL menus either on or off. Turning menus off may be useful if you wish to read the right mouse button. ",
   },
   "WPointer": {
      "prefix": "WPointer",
      "body": "WPointer Shape#",
      "description": "WPointer allows you to determine the mouse pointer imagery used in the currently used window. Shape# specifies an initialized shape object the pointer is to take it's appearance from, and must be of 2 bitplanes depth (4 colours). ",
   },
   "WMove": {
      "prefix": "WMove",
      "body": "WMove X,Y",
      "description": "WMove will move the current window to screen position X,Y . ",
   },
   "WSize": {
      "prefix": "WSize",
      "body": "WSize Width,Height",
      "description": "WSize will alter the width and height of the current window to the values specified by Width and Height. ",
   },
   "WMouseX": {
      "prefix": "WMouseX",
      "body": "WMouseX",
      "description": "WMouseX returns the horizontal x coordinate of the mouse relative to the left edge of the current window. If the current window was opened without the GIMMEZEROZERO flag set, then the left edge is taken as the left edge of the border around the window, otherwise, if GIMMEZEROZERO was set, then the left edge is the taken from inside the window border. ",
   },
   "WMouseY": {
      "prefix": "WMouseY",
      "body": "WMouseY",
      "description": "WMouseY returns the vertical y coordinate of the mouse relative to the top of the current window. If the current window was opened without the GIMMEZEROZERO flag set, then the top is taken as the top of the border around the window, otherwise, if GIMMEZEROZERO was set, then the top is taken trom inside the window border. ",
   },
   "EMouseX": {
      "prefix": "EMouseX",
      "body": "EMouseX",
      "description": "EMouseX will return the horizontal position of the mouse pointer at the time the most recent window event occured. Window events are detected using the WaitEvent or Event commands. ",
   },
   "EMouseY": {
      "prefix": "EMouseY",
      "body": "EMouseY",
      "description": "EMouseY returns vertical position of the mouse pointer at the time the most recent window event occured. Window events are detected using the WaitEvent or Event. ",
   },
   "WCurs": {
      "prefix": "WCurs",
      "body": "WCurs",
      "description": "WCursX returns the horizontal location of the text cursor of the currently used window. The text cursor position may be set using WLocate. ",
   },
   "WCursY": {
      "prefix": "WCursY",
      "body": "WCursY",
      "description": "WCursY returns the vertical location of the text cursor of the currently used window. The text cursor position may be set using WLocate. ",
   },
   "WLocate": {
      "prefix": "WLocate",
      "body": "WLocate X, Y",
      "description": "WLocate is used to set the text cursor position within the currently used window. X and Y are both specified in pixels as offsets from the top left of the window. Each window has it's own text cursor position, therefore changing the text cursor position of one ",
   },
   "window": {
      "prefix": "window",
      "body": "window will not affect any other window's text cursor position.",
      "description": "",
   },
   "WindowX": {
      "prefix": "WindowX",
      "body": "WindowX",
      "description": "WindowX returns the horizontal pixel location of the top left corner of the currently used window, relative to the screen the window appears in. ",
   },
   "WindowY": {
      "prefix": "WindowY",
      "body": "WindowY",
      "description": "WindowY returns the vertical pixel location of the top left corner of the currently used window, relative to the screen the window appears in. ",
   },
   "WindowWidth": {
      "prefix": "WindowWidth",
      "body": "WindowWidth",
      "description": "WindowWidth returns the pixel width of the currently used window. ",
   },
   "WindowHeight": {
      "prefix": "WindowHeight",
      "body": "WindowHeight",
      "description": "WindowHeight returns the pixel height of the currently used window. ",
   },
   "InnerWidth": {
      "prefix": "InnerWidth",
      "body": "InnerWidth",
      "description": "InnerWidth returns the pixel width of the area inside the border of currently window. ",
   },
   "InnerHeight": {
      "prefix": "InnerHeight",
      "body": "InnerHeight",
      "description": "InnerHeight returns the pixel height of the area inside the border of currently window. ",
   },
   "WTopOff": {
      "prefix": "WTopOff",
      "body": "WTopOff",
      "description": "WTopOff returns the number of pixels between the top of the current window border and the inside of the window. ",
   },
   "WLeftOff": {
      "prefix": "WLeftOff",
      "body": "WLeftOff",
      "description": "WLeftOff returns the number of pixels between the left edge of the current window border and the inside of the window. ",
   },
   "SizeLimits": {
      "prefix": "SizeLimits",
      "body": "SizeLimits Min Width,Min Height,Max Width,Max Height",
      "description": "SizeLimits sets the limits that any new windows can be sized to with the Sizing gadget. After calling this statement, any new windows will have these limits imposed on them. ",
   },
   "RastPort": {
      "prefix": "RastPort",
      "body": "RastPort (Window#)",
      "description": "RastPort returns the specified Window's RastPort address. Many commands in the graphics.library and the like require a RastPort as a parameter. ",
   },
   "PositionSuperBitMap": {
      "prefix": "PositionSuperBitMap",
      "body": "PositionSuperBitMap x,y",
      "description": "PositionSuperBitMap is used to display a certain area of the bitmap in a super bitmap window. GetSuperBitMap After rendering changes to a superbitmap window the bitmap attached can also be updated with the GetSuperBitMap. After rendering changes to a bitmap the superbitmap window can be refreshed with the PutSuperBitMap command. Both commands work with the currently used window. PutSuperBitMap See GetSuperBitmap description. ",
   },
   "WTitle": {
      "prefix": "WTitle",
      "body": "WTitle windowtitle$,screentitle$",
      "description": "WTitle is used to alter both the current window's title bar and it's screens title bar. Useful for displaying important stats such as program status etc. ",
   },
   "CloseWindow": {
      "prefix": "CloseWindow",
      "body": "CloseWindow Window#",
      "description": "CloseWindow has been added for convenience. Same as Free Window but a little more intuitive (added for those that have complained about such matters). ",
   },
   "WPrintScroll": {
      "prefix": "WPrintScroll",
      "body": "WPrintScroll",
      "description": "WPrintScroll will scroll the current window upwards if the text cursor is below the bottom of the window and adjust the cursor accordingly. Presently WPrintScroll only works with windows opened with the gimme00 flag set (#gimmezerozero=$400). ",
   },
   "WBlit": {
      "prefix": "WBlit",
      "body": "WBlit Shape#,x,y",
      "description": "WBlit is used to blit any shape to the current window. Completely system friendly this command will completely clip the shape to fit inside the visible part of the window Use GimmeZeroZero windows for clean clipping when the window has title/sizing gadgets. ",
   },
   "BitMaptoWindow": {
      "prefix": "BitMaptoWindow",
      "body": "BitMaptoWindow Bitmap#,Window#[srox,srcy,destx,desty,width,height]",
      "description": "BitMaptoWindow will copy a bitmap to a window in an operating system friendly manner (what do you expect). The main use of such a command is for programs which use the raw bitmap commands such as the 2D and Blit libraries for rendering bitmaps quickly but require a windowing environment for the user inyerface EventCode EventQualifier EventCode returns the actual code of the last Event received by your program, EventQualifier returns the contents of the Qualifier field. Of use with the new GadTools library and some other low level event handling requirements. WindowTags Window#,Flags, Title$,[&TagList] I [[Tag,Data]...] Similar to ScreenTags, WindowTags allows the advanced user to open a Blitz window with a list of OS Tags as described in the documentation for the OS prior to 2.0. ",
   },
   "LoadFont": {
      "prefix": "LoadFont",
      "body": "LoadFont IntuiFont#,Fontname.font$, Y Size [,style]",
      "description": "LoadFont is used to load a font from the fonts: directory. Unlike BlitzFonts any size ",
   },
   "IntuiFont": {
      "prefix": "IntuiFont",
      "body": "IntuiFont can be used. The command WindowFont is used to set text output to a certain ",
      "description": "IntuiFont in a particular Window. The LoadFont command has been extended with an optional style parameter. The following constants may be combined: #underl ined= 1 #bold=2 #italic=4 #extended=8 ;wider than normal #colour=64 ;hmm use colour version I suppose ",
   },
   "ButtonGroup": {
      "prefix": "ButtonGroup",
      "body": "ButtonGroup Group -",
      "description": "ButtonGroup allows you to determine which 'group' a number of button type gadgets belong to. Following the execution of ButtonGroup, any button gadgets created will be identified as belonging to the spiecified group. The upshot of all this is that button gadgets are only mutually exclusive to other button gadgets within the same group. 'Group' must be a positive number greater than 0. Any button gadgets created before a'ButtonGroup' command is executed will belong to group 1. ",
   },
   "SetGadgetStatus": {
      "prefix": "SetGadgetStatus",
      "body": "SetGadgetStatus GadgetList#,Id,Value",
      "description": "SetGadgetStatus is used to set a cycling text gadget to a particular value, once set ReDraw should be used to refresh the gadget to reflect it's new value. ",
   },
   "GadgetPens": {
      "prefix": "GadgetPens",
      "body": "GadgetPens Foreground Colour[,Background Colour]",
      "description": "GadgetPens determines the text colours used when text gadgets are created using the TextGadget command. The default values used for gadget colours are a foreground colour of 1, and a background colour of 0. ",
   },
   "GadgetJam": {
      "prefix": "GadgetJam",
      "body": "GadgetJam Jammode",
      "description": "GadgetJam allows you to determine the text rendering method used when gadgets are created using the TextGadget command. Please refer to the WJam command in the windows chapter for a full description of jam modes available. ",
   },
   "SelectMode": {
      "prefix": "SelectMode",
      "body": "SelectMode mode",
      "description": "SelectMode is used to predefine how gadget rendering will show a gadget selection, modes are 1 for box and 0 for inverse. Use prior to creation of gadgets. ",
   },
   "ShapeGadget": {
      "prefix": "ShapeGadget",
      "body": "ShapeGadget GadgetList#,X,Y,Flags,ld,Shape#[,Shape#",
      "description": "ShapeGadget command allows to create gadgets with graphic imagery. Shape# refers to a shape object containing the graphics you wish the gadget to contain. ShapeGadget command has been extended to allow an alternative image to be displayed when the gadget is selected. All other parameters are identical to those in TextGadget. ",
   },
   "StringGadget": {
      "prefix": "StringGadget",
      "body": "StringGadget GadgetList#,X, Y,Flags,ld,Maxlen, Width",
      "description": "StringGadget allows to create an Intuition style 'text entry' gadget. When clicked on, a string gadget brings up a text cursor, and is ready to accept text entry trom keyboard. X and Y specifies the gadgets, position, relative to the top left of the window it is to appear in. See the beginning of the chapter for the relevant Flags tor a string gadget. Id is an identification value to be attached to this gadget. All gadgets in a gadgetlist should have unique Id numbers, allowing you to detect which gadgets has been selected. Id may be any positive, non-zero number. Maxlen refers to the maximum number of characters which may appear in this gadgets. ",
   },
   "Width": {
      "prefix": "Width",
      "body": "Width refers to how wide, in pixels, the gadget should be. A string gadget may have a ",
      "description": "width less than the maximum number of characters it may contain, as characters will be scrolled through the gadget when necessary. You may read the current contents of a string gadget using the StringText function. ",
   },
   "StringText$": {
      "prefix": "StringText$",
      "body": "StringText$ (GadgetList#,ld)",
      "description": "",
   },
   "Stringtext$": {
      "prefix": "Stringtext$",
      "body": "Stringtext$ function allows you to determine the current contents of a string gadget. ",
      "description": "StringText$ will return a string of characters representing the string gadgets contents. ",
   },
   "ActivateString": {
      "prefix": "ActivateString",
      "body": "ActivateString Window#,ld",
      "description": "ActivateString may be used to 'automatically' activate a string gadget. This is identical to the program user having clicked in the string gadget themselves, as the string gadget's cursor will appear, and further keystrokes will be sent to the string gadget. It is often nice of a program to activate Important string gadgets, as it saves the user the hassle of having to reach t'or the mouse before the keyboard. ",
   },
   "ResetString": {
      "prefix": "ResetString",
      "body": "ResetString GadgetList#,ld",
      "description": "ResetString allows you to 'reset' a string gadget. This will cause the string gadget's cursor position to be set to the leftmost position. ",
   },
   "ClearString": {
      "prefix": "ClearString",
      "body": "ClearString GadgetList#,l",
      "description": "ClearString may be used to clear, or erase, the text in the specified string gadget. The cursor position will also be moved to the leftmost position in the string gadget. If a string gadget is cleared while it is displayed in a window, the text will not be erased from the actual display. To do this, ReDraw must be executed. ",
   },
   "SetString": {
      "prefix": "SetString",
      "body": "SetString GadgetList#, ID, String$",
      "description": "SetString may be used to initialize the contents of a string gadget created with the StringGadget command. If the string gadget specified by GadgetList# and id is already displayed, you will also need to execute ReDraw to display the change. ",
   },
   "PropGadget": {
      "prefix": "PropGadget",
      "body": "PropGadget GadgetList#,X, Y,Flags,ld, Width,Height",
      "description": "The PropGadget command is used to create a 'proportional gadget'. Proportional gadgets present a program user with a 'slider bar', allowing them to adjust the slider to achieve a desired effect. Proportional gadgets are commonly used for the 'R G B' sliders seen in many paint packages. Proportional gadgets have 2 main qualities - a 'pot' (short for potentiometer) setting, and a'body' setting. The pot setting refers to the current position of the slider bar, and is in the range 0 through 1. For example, a proportional gadget which has been moved to 'half way' would have a pot setting of '.5'. The body setting refers to the size of the units the proportional gadget represents, and is again in the range 0 through 1. Again taking the RGB colour sliders as an example, each slider is intended to show a particular value in the range 0 through 15 - giving a unit size, or body setting, of 1/16 or '.0625'. Put simply, the pot setting describes 'where' the slider bar is, while the body setting describes 'how big' it is. Proportional gadgets may be represented as either horizontal slider bars, vertical slider bars, or a combination of both. See the beginning of the chapter for relevant Flags settings for prop gadgets. X and Y refer to the gadgets position, relative to top left of the window it is opened in. Width and Height refer to the size of the area the slider should be allowed to move in. Id is a unique, non zero nr. which allows to identify when the gadget is manipulated. Proportional gadgets may be altered using the SetVProp and SetHProp commands, and read using the VPropPot, VPropBody, HPropPot and HPropBody functions. ",
   },
   "SetHProp": {
      "prefix": "SetHProp",
      "body": "SetHProp GadgetList#,ld,Pot,Bod",
      "description": "SetHProp is used to alter the horizontal slider qualities of a proportional gadget. Both Pot and Body should be in the range 0 through 1. If SetHProp is executed while the specified gadget is already displayed, execution of the ReDraw command will be necessary to display the changes. For a full discussion on proportional gadgets, please refer to the PropGadget command. ",
   },
   "SetVProp": {
      "prefix": "SetVProp",
      "body": "SetVProp GadgetList#,ld,Pot, Body",
      "description": "SetVProp is used to alter the vertical slider qualities of a proportional gadget. Both Pot and Body should be in the range 0 through 1. If SetVProp is executed while the specified gadget is already displayed, execution of the ReDraw command will be necessary to display the changes. ",
   },
   "HPropPot": {
      "prefix": "HPropPot",
      "body": "HPropPot (GadgetList#,ld)",
      "description": "The HPropPot function allows you to determine the current 'pot' setting of a proportional gadget. HPropPot will return a number from 0 up to, but not including, 1, reflecting the gadgets current horizontal pot setting. ",
   },
   "HPropBody": {
      "prefix": "HPropBody",
      "body": "HPropBody (GadgetList#,ld)",
      "description": "The HPropBody function allows you to determine the current 'body' setting of a proportional gadget. HPropBody will return a number from 0 up to, but not including, 1, reflecting the gadgets current horizontal body setting. ",
   },
   "VPropPot": {
      "prefix": "VPropPot",
      "body": "VPropPot (GadgetList#,ld)",
      "description": "The VPropPot function allows you to determine the current 'pot' setting of a proportional gadget. VPropPot will return a number from 0 up to, but not including, 1, reflecting the gadgets current vertical pot setting. ",
   },
   "VPropBody": {
      "prefix": "VPropBody",
      "body": "VPropBody (GadgetList#,ld)",
      "description": "The VPropBody function allows you to determine the current 'body' setting of a proportional gadget. VPropBody will return a number from 0 up to, but not including, 1, reflecting the gadgets current vertical body setting. ",
   },
   "Redraw": {
      "prefix": "Redraw",
      "body": "Redraw Window#,id",
      "description": "ReDraw will redisplay the specified gadget in the specified window. This command is mainly of use when a proportional gadget has been altered using SetHProp or SetVProp and needs to be redrawn, or when a string gadget has been cleared using ClearString, and, likewise, needs to be redrawn. ",
   },
   "Borders": {
      "prefix": "Borders",
      "body": "Borders [On I Off] I [Width, Height]",
      "description": "Borders serves 2 purposes. First, Borders may be used to turn on or off the automatic creation of borders around text and string gadgets. Borders are created when either a Textgadget or StringGadget command is executed. If you wish to disable this, Borders Off should be executed before the appropriate TextGadget or StringGadget command. Borders may also be used to specify the spacing between a gadget and it's border, Width referring to the left/right spacing, and Height to the above/below spacing. ",
   },
   "BorderPens": {
      "prefix": "BorderPens",
      "body": "BorderPens Highlight Colour,Shadow Colour",
      "description": "BorderPens allows you to control the colours used when gadget borders are created. Gadget borders may be created by the TextGadget, StringGadget and GadgetBorder. HighLight Colour refers to the colour of the top and left edges of the border, while Shadow Colour refers to the right and bottom edges. The default value for HighLight Colour is 1. The default value for Shadow Colour is 2. ",
   },
   "Gadget": {
      "prefix": "Gadget",
      "body": "Gadget Border X, Y, Width, Height",
      "description": "The GadgetBorder command may be used to draw a rectangular border into the currently used window. Proportional gadgets and shape gadgets do not have borders automatically created tor them. The GadgetBorder command may be used, once a window is opened, to render borders around these gadgets. X,Y, Width and Height refer to the position of the gadget a border is required around. GadgetBorder will automatically insert sapces between the gadget and the border. The Borders command may be used to alter the amount of spacing. Of course, GadgetBorder may be used to draw a border around any arbitary area, regardless of whether or not that area contains a gadget. ",
   },
   "GadgetStatus": {
      "prefix": "GadgetStatus",
      "body": "GadgetStatus (GadgetList#,ld)",
      "description": "GadgetStatus may be used to determine the status of the specified gadget. In the case of toggle' type gadget, GadgetStatus will return true (-1) if the gadget is currently on, or false (0) if the gadget is currently off. In the case of a cycling text gadget, GadgetStatus will return a value of 1 or greater representing the currently displayed text within the gadget. ",
   },
   "ButtonId": {
      "prefix": "ButtonId",
      "body": "ButtonId (GadgetList#,ButtonGroup)",
      "description": "ButtonId its used to determine which gadget within a group of button type gadgets is currently selected. The value returned will be the GadgetId of the button gadget currently selected. Enable GadgetList#,ld A gadget when disabled is covered by a \"mesh\" and can not be accessed by the user. Commands Enable & Disable allow the programmer to access this feature of Intuition. Disable GadgetList#,ld A gadget when disabled is covered by a \"mesh\" and can not be accessed by the user. Commands Enable & Disable allow the programmer to access this feature of Intuition. ",
   },
   "Toggle": {
      "prefix": "Toggle",
      "body": "Toggle GadgetList#,ld [,On I Off]",
      "description": "The Toggle command in the gadget library has been extended so it will actually toggle a gadgets status if the On I Off parameter is missing. ",
   },
   "MenuTitle": {
      "prefix": "MenuTitle",
      "body": "MenuTitle Menulist#,Menu,Title",
      "description": "MenuTitle is used to add a menu title to a menulist. Menu titles appear when the right mouse button is held down, and usually have menuitems attached to them. Menu specifies which menu the title should be used for. Higher numbered menus appear further to the right along the menu bar, with 0 being the leftmost menu. Menutitles should be added in left to right order, with menu 0 being the first created, then 1 and so on... Title$ is the actual text you want to appear when the right mouse button is pressed. ",
   },
   "Menultem": {
      "prefix": "Menultem",
      "body": "Menultem MenuList#, Flags, Menu,ltem,ltemtext$[, Shortcut$]",
      "description": "Menultem is used to create a text menu item. Menu items appear vertically below menu titles when mouse is moved over a menu title with the right mouse button held down. Flags affects operation of menu item. A value of 0 creates a stand 'select' menu item. A value of 1 creates a 'toggle' menu item. Toggle menu items are used for 'on/off' type options. When a toggle menu item is selected, it will change state between on and off. An 'on' toggle item is identified by a 'tick' or check mark A value of 2 creates a special type of toggle menu item. Any menu items which appear under the same menu with a Flags setting of 2 are said to be mutually exclusive. This means that only 1 of them may begin the 'on' state at one time. If a menu item of this nature is toggled into the 'on' state, any other mutually exclusive menu items which may have previously been 'on' will be automatically turned 'off'. Flags values of 3 and 4 correspond to values 1 and 2, only the item will initially appear in the 'on' state. Menu specifies the menu title under which the menu item should appear. Item specifies the menu item number, this menu item should be referenced as. Higher numbered items appear further down a menu item list, with 0 being topmost item. Menu items should be added in 'top down' order, with item 0 being the first item created. Itemtext$ is the actual text for the menu item. An optional Shortcut$ string allows you to select a one character 'keyboard shortcut' for the menu item. Shapeltem MenuList#, Flags,Menu, Item, Shape# ShapeItem is used to create a graphical menu item. Shape# refers to a previously initialized shape object to be used as the menu item's graphics. All other parameters are identical to those for MenuItem. Subitem MenuList#,Flags,Menu,ltem,Subitem,Subitem text$[,Shortcut$] All menu items may have an optional list of sub menu items attached to them. To attach a sub menu item to a menu item, you use the SubItem command. Item specifies the menu item to attach the sub item to. Subitem refers to the number of the sub menu item to attach. Higher numbered ",
   },
   "sub": {
      "prefix": "sub",
      "body": "sub items appear further down a sub item list, with 0 being the topmost sub item. ",
      "description": "Sub items should be added in 'top down' order, with sub item 0 being created first. .  Subitemtext$ specifies the actual text for the sub item. As with menu items, sub items may have an optional keyboard shortcut, specified using Shortcut$ parameter. All other parameters are identical to the MenuItem command. ",
   },
   "ShapeSub": {
      "prefix": "ShapeSub",
      "body": "ShapeSub MenuList#,Flags,Menu,ltem,Subitem,Shape#",
      "description": "ShapeSub allows you to create a graphic sub menu item. Shape# specifies a previously created shape object to be used as the sub item's graphics. All other parameters are identical to those in SubItem. ",
   },
   "SetMenu": {
      "prefix": "SetMenu",
      "body": "SetMenu MenuList#",
      "description": "SetMenu is used to attach a menulist to the currently used window. Each window may have only one menulist attached to it. MenuGap X Gap, Y Gap Executing MenuGap before creating any menu titles, items or sub items, allows you to control the layout of the menu. X Gap refers to an amount, specified in pixles, to be inserted to the left and right of all menu items and sub menu items. Y Gap refers to an amount, again in pixels, to be inserted above and below all menu items and sub menu items. ",
   },
   "SubitemOff": {
      "prefix": "SubitemOff",
      "body": "SubitemOff X Offset, Y Offset",
      "description": "SubItemOff allows you to control the relative position of the top of a list of sub menu items, in relation to their associated menu item. Whenver a menu item is created which is to have sub menu items, it's a good idea to append the name of the menu item with the '>>' character. This may be done using Chr$(187). This gives the user a visual indication that more options are available. To position the sub menu items correctly so that they appear after the '>>' character, SubItemOff should be used. ",
   },
   "MenuState": {
      "prefix": "MenuState",
      "body": "MenuState MenuList#[ Menu[, Item[, Subitem]]], On l Off",
      "description": "The MenuState command allows you to turn menus, or sections of menus, on or off. ",
   },
   "MenuState": {
      "prefix": "MenuState",
      "body": "MenuState with just MenuList# parameter its used to turn an entire menu list on or off.",
      "description": "MenuState with MenuList# and Menu parameters may be used to turn a menu on or off. Similarly, menu items and sub items may be turned on or off by specifying the appropriate parameters. ",
   },
   "MenuColour": {
      "prefix": "MenuColour",
      "body": "MenuColour Colour",
      "description": "MenuColour allows to determine what colour any menu item or sub item text is rendered in. MenuColour should be executed before appropriate menu item commands. ",
   },
   "MenuChecked": {
      "prefix": "MenuChecked",
      "body": "MenuChecked (MenuList#, Menu,ltem[, Subitem]",
      "description": "The MenuChecked function allows you to tell whether or not a 'toggle' type menu item or menu sub item is currently 'checked' or ton'. If the specified menu item or sub item is in fact checked, MenuChecked will return 'true' (-1). If not, MenuChecked will return 'false' (0). GTButton GTList#, id,x,y, w,h, Text$, flags Same as Blitz's TextGadget but with the added flexibility of placing the label Text$ above, below to the left or right of the button (see flags). GTCheckBox GTList#,id,x,y, w,h, Text$, flags A box with a check mark that toggles on and off, best used for options that are either enabled or disabled GTCycle GTList#,id,x,y, w,h, Text$, flags, Options$ Used for offering the user a range of options, the options string should be a list of options separated by the l character ea. \"HIRES l LORES l SUPER HIRES \" GTlnteger GTList#,id,x,y, w,h, Text$, flags, default ",
   },
   "A": {
      "prefix": "A",
      "body": "A string gadget that allows only numbers to be entered by the user.See GTSetInteger ",
      "description": "and GTGetInteger for information about accessing the contents of a GTInteger gadget. GTListView GTList#,id,x,y,w,h, Text$, flags, list0 ListView gadget enables user to scroll through a list of options. These options must be contained in a string field of a Blitz linked list. Currently this string field must be the 2nd field, the first being a word type. See the GTChangeList command for more details. ",
   },
   "GTMX": {
      "prefix": "GTMX",
      "body": "GTMX GTList#,id,x,y,w,h, Text$, flags, Options$",
      "description": "GTMX is an exclusive selection gadget, the Options$ is the same as GTCycle in format, GadTools then displays all the options in a vertical list each with a hi-light beside them. GTNumber GTList#,id,x,y,w,h, Text$, flags, value This is a readonly gadget (user cannot interact with it) used to display numbers. See GTSetInteger to update the contents of this read only \"display\" gadget. GTPalette GTList#,id,x,y,w,h, Text$, flags, depth Creates a number of coloured boxes relating to a colour palette, GTScroller GTList#,id,x,y,w,h, Text$, flags, Visible, Total A prop type gadget for the user to control an amount or level, is accompanied by a set of arrow gadgets GTSlider GTList#,id,x,y,w,h, Text$, flags, Min, Max Same as Scroller but for controlling the position of the display inside a larger view. GTString GTList#,id,x,y,w,h, Text$, flags, MaxChars A standard string type gadget. See GTSetString and GTGetString for accessing the contents of a GTString gadget. GTText GTList#,id,x,y,w,h, Text$, flags, Display$ A read only gadget (see GTNumber) for displaying text messages. See GTSetString for updating the contents of this read only \"display\" gadget. GTShape GTList#,id,x,y, flags, Shape#[, Shape#] Similar to the Blitz ShapeGadget allowing IFF graphics that are loaded int Blitz shape objects to be used as gadgets in a window. ",
   },
   "AttachGTList": {
      "prefix": "AttachGTList",
      "body": "AttachGTList GTList#, Window#",
      "description": "The AttachGTList command is used to attach a set of GadTools gadgets to a Window after it has been opened. ",
   },
   "GTTags": {
      "prefix": "GTTags",
      "body": "GTTags Tag, Value 1,Tag, Value...]",
      "description": "The GTTags command can be used prior to initialization of any of the 12 gadtools gadgets to preset any relevant Tag fields. The following are some useful Tags that can be used with GTTags: #tag=$80080000 #GTCB Checked=#tag+4 ; State of checkbox #GTLV_Top=#tag+5 ; Top visible item in listview #GTLV_ReadOnly=#tag+7 ; Set TRUE if lisiview is ReadOnly #GTMX_Active=#tag+10 ; Active one in mx gadget #GTTX_Text=#tag+11 ; Text to display #GTNM_Number=#tag+ 13 ; Number to display #GTCY_Active=#tag+ 15 ; The active one in the cycle gad #GTPA_Color=#tag+ 17 ; Palette color #GTPA ColorOffset=#tag+18 ; First color to use in palette #GTSC_Top=#tag+21 ; Top visible in scroller #GTSC_Total=#tag+22 ; Total in scroller area #GTSC_Visible=#tag+23 ; Number visible in scroller #GTSL_Level=#tag+40 ; Slider level #GTSL_MaxLevelLen=#tag+41 ; Max length of printed level #GTSL_LevelFormat=#tag+42 ;* Format string for level #GTSL_LevelPlace=#tag+43 ;* Where level should be placed #GTLV_Selected=#tag+54 ; Set ordinal number of selected #GTMX_Spacing=#tag+61 ;* Added to font height All of the above except for those marked * can be set after initialization of the Gadget using the GTSetAttrs command. The following is an example of creating a slider gadget with a numeric display: f$=\"%21d  \"GTTags#GTSLLevelFormat,&f$,#GTSLMaxLevelLen,4GTSlider 2,10,320,120,200,20,\"GTSLIDER\",2,0,10 ",
   },
   "GTGadPtr": {
      "prefix": "GTGadPtr",
      "body": "GTGadPtr (GTList#,id)",
      "description": "GTGadPtr returns the actual location of the specified GadTools gadget in memory. ",
   },
   "GTBevelBox": {
      "prefix": "GTBevelBox",
      "body": "GTBevelBox GTList#,x,y,w,h,flags",
      "description": "GTBevelBox is the GadTools library equivalent of the Borders command and can be used to render frames and boxes in the currently used Window ",
   },
   "GTChangeList": {
      "prefix": "GTChangeList",
      "body": "GTChangeList GTList#,id [,List()]",
      "description": "GTChangeList must be used whenever a List attached to a GTListView needs to be modified. Call GTChangeList without the List() parameter to free the List, modify it then reattach it with another call to GTChangeList this time using the List() parameter. ",
   },
   "GTSetAttrs": {
      "prefix": "GTSetAttrs",
      "body": "GTSetAttrs GTList#,id [, Tag, Value...]",
      "description": "GTSetAttrs can be used to modify the status of certain GadTools gadgets with the relevant Tags. See GTTags for more information. GTSetString GTList#,id,string$ Used with both GTString and GTText gadgets, GTSetString will not only update the contents of the gadget but redraw it also. GTSetinteger GTList#,id,value Used with both GTInteger and GTNumber gadgets, GTSetInteger will not only update the contents of the gadget but redraw it also. GTGetString GTList#,id Used to read the contents from a GTString gadget. GTGetinteger GTList#,id Used to read the contents from a GTlnteger gadget. GTGetAttrs (GTList#,id,Tag) A 3.0 specific command. See C= documentation for more information. GTEnable GTList#,ld Allows GTGadgets to be enabled and disabled. GTDisable GTList#,ld Allows GTGadgets to be enabled and disabled. ",
   },
   "GTToggle": {
      "prefix": "GTToggle",
      "body": "GTToggle GTList#,ld[,On l Off]",
      "description": "GTToggle allows the programmer to set Boolean gadgets such as GTButton and GTCheckbox to a desired state. ",
   },
   "GTStatus": {
      "prefix": "GTStatus",
      "body": "GTStatus (GTList#,ld)",
      "description": "GTStatus returns the status of the gadtools toggle gadgets, a value of 1 means the the gadget is selected, 0 deselected. ASLPathRequest$ (Title$,Pathname$ [,x,y,w,h]) Same as ASLFileRequest$ except will just prompt the user for a path name (directory) rather than an actual file. ASLFontRequest (enable flags) The ASL Font Requester is also pretty useful. The flags parameter enables the user to modify the following options: #pen=1 :#bckgrnd=2:#style=4:#drawmode=8:#fixsize=16 It doesn't seem to handle colour fonts, no keyboard shortcuts so perhaps patching ReqTools is an option for this one. The following code illustrates how a .fontinfo structure is created by a call to ASLFontRequest (just like in high level language man!). ASLScreenRequest (enable flags) Those who are just getting to grips with 2.0 and above will find this command makes your programs look really good, however I haven't got time to explain the difficulties of developing programs that work in all screen resolutions (what are ya?). NEWTYPE .fontinfo name.s ysize.w style.b:flags.b pen1.b:pen2:drawmode:pad End NEWTYPE FindScreen 0 *f.fontinfo=ASLFontRequest(15) If * ",
   },
   "NPrint": {
      "prefix": "NPrint",
      "body": "NPrint *f\\name",
      "description": "",
   },
   "NPrint": {
      "prefix": "NPrint",
      "body": "NPrint *f\\ysize",
      "description": "",
   },
   "NPrint": {
      "prefix": "NPrint",
      "body": "NPrint *f\\penl",
      "description": "",
   },
   "NPrint": {
      "prefix": "NPrint",
      "body": "NPrint *f\\pen2",
      "description": "NPrint *f\\drawmode Else NPrint \"cancelled\" Endif MouseWait ",
   },
   "CreateMsgPort": {
      "prefix": "CreateMsgPort",
      "body": "CreateMsgPort (\"Name\")",
      "description": "",
   },
   "CreateMsgPort": {
      "prefix": "CreateMsgPort",
      "body": "CreateMsgPort is a general Function and not specific to ARexx.",
      "description": "CreateMsgPort opens an intuition PUBLIC message port of the name supplied as the only argument. If all is well the address of the port created will be returned to you as a LONGWORD so the variable that you assign it to should be of type long. If you do not supply a name then a private MsgPort will be opened for you. Port. 1=CreateMsgPort( \" PortName\" ) It is important that you check you actually succeeded in opening a port in your program. The following code or something similar will suffice. Port. 1=CreateMsgPort( \"Name\" ) IF Port=0 THEN Error_Routine{ } The name you give your port will be the name that Arexx looks for as the HOST address,(and is case sensitive) so take this into consideration when you open your port. NOTE IT MUST BE A UNIQUE NAME AND SHOULD NOT INCLUDE SPACES. DeleteMsgPort() is used to remove the port later but this is not entirely necessary as Blitz will clean up for you on exit if need be. ",
   },
   "DeleteMsgPort": {
      "prefix": "DeleteMsgPort",
      "body": "DeleteMsgPort (Port)",
      "description": "DeleteMsgPort deletes a MessagePort previously allocated with CreateMsgPort(). The only argument taken by DeleteMsgPort is the address returned by CreateMsgPort(). If the Port was a public port then it will be removed from the public port list. Port. 1=CreateMsgPort( \"Name\") IF Port=0 Then End DeleteMsgPort Port Error checking is not critical as if this fails we have SERIOUS PROBLEMS YOU MUST WAIT FOR ALL MESSAGES FROM AREXX TO BE RECEIVED BEFORE YOU DELETE THE MSGPORT.IF YOU NEGLECT TO DELETE A MSGPORT BLITZ2 WILL DO IT FOR YOU AUTOMATICALLY ON PROGRAM EXIT. ",
   },
   "CreateRexxMsg": {
      "prefix": "CreateRexxMsg",
      "body": "CreateRexxMsg (ReplyPort,\"exten' \"HOST\")",
      "description": "CreateRexxMsg() allocates a special Message structure used to communicate with Arexx. If all is successful it returns the LONGWORD address of this rexxmsg structure. The arguments are ReplyPort which is the long address returned by CreateMsgPort(). This is the Port that ARexx will reply to after it has finished with the message. EXTEN which is the exten name used by any ARexx script you are wishing to run. i.e. if you are attempting to run the ARexx script test.rexx you would use an EXTEN of \"rexx\" HOST is the name string of the HOST port. Your program is usually the HOST and so this equates to the name you gave your port in CreateMsgPort(). REMEMBER IT IS CASE SENSITIVE. As we are allocating resources error checking is important and can be achieved with the following code: msg.l=CreateRexxMsg(Port, \"rexx\",\"HostName\" ) IF msg=0 THEN Error_Routine{ } DeleteRexxMag rexxmsg DeleteRexxMsg simply deletes a RexxMsg Structure previously allocated by CreateRexxMsg(). It takes a single argument which is the long address of a RexxMsg structure such as returned by CreateRexxMsg(). msg.l=CreateRexxMsg(Port, \"rexx \",\"HostName\") IF msg=0 THEN Error Routine( } DeleteRexxMsg msg Again if you neglect to delete the RexxMsg structure Blitz will do this for you on exit of the program. ",
   },
   "ClearRexxMsg": {
      "prefix": "ClearRexxMsg",
      "body": "ClearRexxMsg Arexxmsg",
      "description": "ClearRexxMsg is used to delete and clear an ArgString from one or more of the Argument slots in a RexxMsg Structure. This is most useful for the more advanced programmer wishing to take advantage of the Arexx #RXFUNC abilities. The arguments are a LONGWORD address of a RexxMsg structure. ClearRexxMsg will always work from slot number 1 forward to 16. ",
   },
   "FillRexxMsg": {
      "prefix": "FillRexxMsg",
      "body": "FillRexxMsg ( rexxmsg,&FillStruct)",
      "description": "FillRexxMsg allows you to fill all 16 ARGSlots if necessary with either ArgStrings or numerical values depending on your requirement. FillRexxMsg will only be used by those programmers wishing to do more advanced things with Arexx, including adding libraries to the ARexx library list, adding Hosts,Value Tokens etc. It is also needed to access Arexx using the #RXFUNC flag. The arguments are a LONG Pointer to a rexxmsg. The LONG address of a FillStruct NEWTYPE structure. This structure is defined in the Arexx.res and has the following form. NEWTYPE .FillStruct Flags.w ;Flag block Args0.l ; argument block (ARG0-ARG15) Args1.l ; argument block (ARG0-ARG15) Args2.l ; argument block (ARG0-ARG15) Args3.l ; argument block (ARG0-ARG15) Args4.l ; argument block (ARG0-ARG15) Args5.l ; argument block (ARG0-ARG15) Args6.l , argument block (ARG0-ARG15) Args7.l , argument block (ARG0-ARG15) Args8.l ; argument block (ARG0-ARG15) Args9.l ; argument block (ARG0-ARG15) Args10.l ; argument block (ARG0-ARG15) Args11.l ; argument block (ARG0-ARG15) Args12.l ; argument block (ARG0-ARG15) Args13.l ; argument block (ARG0-ARG15) Args14.l ; argument block (ARG0-ARG15) Args15.l ; argument block (ARG0-ARG15) EndMark.l ; End of the FillStruct End NEWTYPE The Args?.l are the 16 slots that can possibly be filled ready for converting into the RexxMsg structure. The Flags.w is a WORD value representing the type of LONG word you are supplying for each ARGSLOT (Arg?.l). Each bit in the Flags WORD is representative of a single Args?.l, where a set bit represents a numerical value to be passed and a clear bit represents a string argument to be converted into a ArgString before installing in the RexxMsg. The Flags Value is easiest to supply as a binary number to make the bits visible and would look like this. %0000000000000000  ;represents that all Arguments are Strings. %0110000000000000  ;represent second&third as being integers. FillRexxMsg expects to find the address of any strings in the Args?.l slots so it is important to remember when filling a FillStruct that you must pass the string address and not the name of the string. This is accomplished using the '&' address of operand. So to use FillRexxMsg we must do the following things in our program: 1. Allocate a FillStruct 2. Set the flags in the FillStruct\\Flags. 3. Fill the FillStruct with either integer values or the addresses of our string arguments. 4. Call FillRexxMsg with the LONG address of our rexxmsg and the LONG address of our   FillStruct. To accomplish this takes the following code: ;Allocate our FillStruct (called F) DEFTYPE.FillStruct F ;assign some string arguments T$=\"open \" :T1$=\"-0123456789\" ;Fill in our FillStruct with flags and (&) addresses of our strings F\\Flags= %0010000000000000,&T$,&T1$,4 ;Third argument here is an integer (4). Port.l=CreateMsgPort( \"host\") msg.l=CreateRexxMsg(Port,\"vc\",\"host\") FillRexxMsg msg,&F ;<-3 ergs see #RXFUNC SendRexxCommand msg,\"\",#RXFUNCI #RXFF RESULTI 3 ",
   },
   "CreateArgString": {
      "prefix": "CreateArgString",
      "body": "CreateArgString (\"this is a string\")",
      "description": "CreateArgString() builds an ARexx compatible ArgString structure around the provided string. All strings sent to, or received from Arexx are in the form of ArgStrings. See the TYPE RexxARG. If all is well the return will be a LONG address of the ArgString structure. The pointer will actually point to the NULL terminated String with the remainder of the structure available at negative offsets. ",
   },
   "DeleteArgString": {
      "prefix": "DeleteArgString",
      "body": "DeleteArgString ArgString",
      "description": "DeleteArgString is designed to Delete ArgStrings allocated by either Blitz or ARexx in a system friendly way. It takes only one argument the LONGWORD address of an ArgString as returned by CreateArgString(). ",
   },
   "SendRexxCommand": {
      "prefix": "SendRexxCommand",
      "body": "SendRexxCommand rexxmsg, \"commands/ring \",#RXCOMMI #RXFF RESULT",
      "description": "SendRexxCommand is designed to fill and send a RexxMsg structure to ARexx inorder to get ARexx to do something on your behalf. The arguments are as follows; rexxmsg: the LONGWORD address of a RexxMsg structure as returned by CreateRexxMsg(). commands/ring: the command string you wish to send to ARexx. This is a string as in \"this is a string\" and will vary depending on what you wish to do with ARexx. Normally this will be the name of an ARexx script file you wish to execute. ARexx will then look for the script by the name as well as the name with the exten added.(this is the exten you used when you created the RexxMsg structure using CreateRexxMsg()). This could also be a string file. That is a complete ARexx script in a single line. ActionCodes: the flag values you use to tell ARexx what you want it to do with the commandstring you have supplied. ",
   },
   "COMMAND": {
      "prefix": "COMMAND",
      "body": "COMMAND (ACTION) CODES",
      "description": "The command codes that are currently implemented in the resident process are described below. Commands are listed by their mnemonic codes,followed by the valid ",
   },
}