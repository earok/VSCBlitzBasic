{
    "Goto": {
        "prefix": "Goto",
        "body": "Goto Label",
        "description": "Goto causes program flow to be transferred to the specified program label. This allows sections of a program to be 'skipped' or 'repeated'."
    },
    "Gosub": {
        "prefix": "Gosub",
        "body": "Gosub Label",
        "description": "Gosub operates in two steps. First, the location of the instruction following the Gosub is remembered in a special storage area (known as the 'stack'). Secondly, program flow is transferred to the specified Program Label. The section of program that program flow is transferred to is known as a subroutine' and should be terminated by a Return command."
    },
    "Return": {
        "prefix": "Return",
        "body": "Return",
        "description": "Return is used to return program flow to the instruction following the previously executed Gosub command. This allows the creation of 'subroutines' which may be called from various points in a program."
    },
    "On": {
        "prefix": "On",
        "body": "On Expression Goto|Gosub Label1 Label2...",
        "description": "If the specified Expression results in a 1, then the first Program Label will be branchedto. A result of 2 will cause the second Program Label to be branched to and so on. If the result of Expression is less than one, or not enough Program Labels are supplied, program flow will continue without a branch."
    },
    "End": {
        "prefix": "End",
        "body": "End",
        "description": "End will halt program flow completely. In case of programs run from Blitz editor, youwill be returned to editor. In case of executable files, will be returned to WB or CLI."
    },
    "Stop": {
        "prefix": "Stop",
        "body": "Stop",
        "description": "Stop command causes the Blitz Debugger to interrupt program flow. Place Stop commands in your code as breakpoints when debugging, ensure runtime errors areenabled. Click on Run from the debugger to continue program flow after a Stop."
    },
    "If": {
        "prefix": "If",
        "body": [
            "If Expression",
            "Endif"
        ],
        "description": "If allows execution of a section of program depending on the result of an expression. The Then command indicates only the rest of the line will be defined as the section ofcode to either execute or not. Without a Then the section of code will be defined asthat up to the EndIf command."
    },
    "Endif": {
        "prefix": "Endif",
        "body": "Endif",
        "description": "EndIf is used to terminate an 'If block'. An If block is begun by use of If statement without the then present. Please refer to If for more information on If blocks."
    },
    "Else": {
        "prefix": "Else",
        "body": "Else",
        "description": "Else may be used after an If to cause program instructions to be executed if the expression specified in the If proved to be false."
    },
    "While": {
        "prefix": "While",
        "body": [
            "While Expression",
            "Wend"
        ],
        "description": "While command is used to execute a series of commands repeatedly while the specified Expression proves to be true. The commands to be executed include all the commands following the While until the next matching Wend."
    },
    "Wend": {
        "prefix": "Wend",
        "body": "Wend",
        "description": "Wend is used in conjunction with While to determine a section of program to be executed repeatedly based upon the truth of an expression."
    },
    "Select": {
        "prefix": "Select",
        "body": [
            "Select Expression",
            "\tCase Expression",
            "\tDefault",
            "End Select"
        ],
        "description": "Select examines and 'remembers' the result of the specified Expression. The Case commands may then be used to execute different sections of program code depending on the result of the expression in the Select line."
    },
    "Case": {
        "prefix": "Case",
        "body": "Case Expression",
        "description": "A Case is used following a Select to execute a section of program code when ,and only when, the Expression specified in the Case statement is equivalentto the Expression evaluated in the Select statement. If a Case statement is satisfied, program flow will continue until the next Case Default or End Select statement is encountered, at which point program flow will branch to the next matching End Select."
    },
    "Default": {
        "prefix": "Default",
        "body": "Default",
        "description": "A Default statement may appear following a series of Case statements to cause a section of code to be executed if NONE of the Case statements were satisfied."
    },
    "End Select": {
        "prefix": "End Select",
        "body": "End Select",
        "description": "End Select terminates a Select...Case...Case...Case sequence. If program flow hadbeen diverted through the use of a Case or Default statement, it will continue from the terminating End Select."
    },
    "For": {
        "prefix": "For",
        "body": [
            "For Var = Expression1 To Expression2 [Step Expression3]",
            "Next"
        ],
        "description": "The For statement initializes a For...Next loop. All For/Next loops must begin with a For statement, and must have a terminating Next statement further down the program.For..Next loops cause a particular section of code to be repeated a certain number oftimes. The For statement does most of the work in a For/Next loop. When For is executed, the variable specified by Var (known as the index variable) will be set to the value Expressionl. After this, the actual loop commences."
    },
    "Next": {
        "prefix": "Next",
        "body": "Next [var[,Var..]]",
        "description": "Next terminates a For..Next loop."
    },
    "Repeat": {
        "prefix": "Repeat",
        "body": [
            "Repeat",
            "Until Expression"
        ],
        "description": "Repeat is used to begin a Repeat...Until loop. Each Repeat statement in a program must have a corresponding Until further down the program. The purpose of Repeat/Until loops is to cause a section of code to be executed AT LEAST ONCE before a test is made to see if the code should be executed again"
    },
    "Until": {
        "prefix": "Until",
        "body": "Until Expression",
        "description": "Until is used to terminate a Repeat/Until loop. If Expression is true (non 0) program flow will continue from the command following Until. If Expression is false (0) program flow will go back to the corresponding Repeat,found further up the program"
    },
    "Forever": {
        "prefix": "Forever",
        "body": "Forever",
        "description": "Forever may be used instead of Until to cause a Repeat/Until loop to NEVER exit. Executing Forever is identical to executing 'Until 0'."
    },
    "Pop": {
        "prefix": "Pop",
        "body": "Pop Gosub|For|Select|If|While|Repeat",
        "description": "Sometimes, it may be necessary to exit from a particular type of program loop in order to transfer program flow to a different part of program. Pop must be included before the Goto which transfers program flow out from the inside of the loop. Actually, Pop is only necessary to prematurely terminate Gosubs, Fors and Selects. If, While and Repeat have been included for completeness but are not necessary."
    },
    "MouseWait": {
        "prefix": "MouseWait",
        "body": "MouseWait",
        "description": "MouseWait halts program until left mouse button is pushed. If left mouse is already held down when a MouseWait is executed, program will simply continue through. MouseWait should normally be used only for program testing purposes, as MouseWait severely slows down multi-tasking."
    },
    "VWait": {
        "prefix": "VWait",
        "body": "VWait [Frames]",
        "description": "VWait will cause program flow to halt until the next vertical blank occurs. Optional Frames parameter may be used to wait for a particular number of vertical blanks. VWait is especially useful in animation for synchrodizing display changes with the rate at which the display is physically redrawn by the monitor."
    },
    "Statement": {
        "prefix": "Statement",
        "body": [
            "Statement Procedurename{Parameters...}",
            "\tStatement Return",
            "End Statement"
        ],
        "description": "Statement declares all following code up to the next End Statement as being a 'statement type' procedure. Up to 6 Parameters may be passed to a statement in the form of local variables through which calling parameters are passed. In Blitz, all statements and functions must be declared before they are called."
    },
    "End Statement": {
        "prefix": "End Statement",
        "body": "End Statement",
        "description": "End Statement declares the end of a 'statement type' procedure definition. All statement type procedures must be terminated with an End Statement."
    },
    "Statement Return": {
        "prefix": "Statement Return",
        "body": "Statement Return",
        "description": "Statement Return may be used to prematurely exit from a 'statement type' procedure. Program flow will return to the command following the procedure call."
    },
    "Function": {
        "prefix": "Function",
        "body": [
            "Function[.type] Procedurename{Parameters...}",
            "\tFunction Return Expression",
            "End Function"
        ],
        "description": "Function declares all following code up to the next End Function as being a function type procedure. The optional Type parameter may be used to determine what type of result is returned by the function. Type. If specified, must be one Blitz's 6 primitive variable types. If no Type is given, the current default type is used. Up to 6 parameters may be passed to a function in form of local variables through which calling parameters are passed. Functions may return values through the Function Return command. In Blitz, all statements and functions must be declared before they are called."
    },
    "End Function": {
        "prefix": "End Function",
        "body": "End Function",
        "description": "End Function declares the end of a 'function type' procedure definition. All function type procedures must be terminated with an End Function."
    },
    "Function Return": {
        "prefix": "Function Return",
        "body": "Function Return Expression",
        "description": "Function Return allows 'function type' procedures to return values to their calling expressions. Function type procedures are called from within Blitz expressions."
    },
    "Shared": {
        "prefix": "Shared",
        "body": "Shared Var[,Var...]",
        "description": "Shared is used to declare certain variables within a procedure definition as being global variables. Any variables appearing within a procedure definition that do n<>t appear in a Shared statement are, by default, local variables."
    },
    "SetInt": {
        "prefix": "SetInt",
        "body": [
            "SetInt Type",
            "End SetInt"
        ],
        "description": "Setint is used to declare a section of program code as 'interrupt' code. Often, when a computer program is running,an event of some importance takes place which must be processed immediately."
    },
    "End SetInt": {
        "prefix": "End SetInt",
        "body": "End SetInt",
        "description": "End SetInt must appear after a SetInt to signify the end of a section of interrupt handler code. Please refer to SetInt for more information of interrupt handlers."
    },
    "ClrInt": {
        "prefix": "ClrInt",
        "body": "ClrInt",
        "description": "ClrInt may be used to remove any interrupt handlers currently attached to specified interrupt Type. SetInt is used to attach interrupt handlers to particular interrupts."
    },
    "SetErr": {
        "prefix": "SetErr",
        "body": [
            "SetErr",
            "End SetErr"
        ],
        "description": "The SetErr command allows you to set up custom error handlers. Program code which appears after the SetErr command will be executed when any Blitz runtime errors are caused. Custom error code should be ended by an End SetErr."
    },
    "End SetErr": {
        "prefix": "End SetErr",
        "body": "End SetErr",
        "description": "End SetErr must appear following custom error handlers installed using SetErr. Please refer to SetErr tor more information on custom error handlers."
    },
    "ClrErr": {
        "prefix": "ClrErr",
        "body": "ClrErr",
        "description": "ClrErr may be used to remove a custom error handler set up using SetErr."
    },
    "ErrFail": {
        "prefix": "ErrFail",
        "body": "ErrFail",
        "description": "ErrFail may be used within custom error handlers to cause a 'normal' error. The error which caused the custom error handler to be executed will be reported and transfer will be passed to direct mode."
    },
    "Let": {
        "prefix": "Let",
        "body": "Let Var=Expression",
        "description": "Let is an optional command used to assign a value to a variable. Let must always be followed by a variable name and an expression.An equals sign ('=') is placed between the variable name and the expression. If the equals sign is omitted, then an opertor (eg: '+', '*') must appear between the variable name and the expression. In this case, the specified variable will be altered by the specified operator and expression."
    },
    "Exchange": {
        "prefix": "Exchange",
        "body": "Exchange Var Var",
        "description": "Exchange will 'swap' the values contained in the 2 specified variables. Exchange may only be used with 2 variables of the same type."
    },
    "MaxLen": {
        "prefix": "MaxLen",
        "body": "MaxLen StringVar=Expression",
        "description": "MaxLen sets aside a block of memory for a string variable to grow into. This is normally only necessary in the case of special Blitz commands which require this space to be present before execution. Currently, only 2 Blitz commands require the use of MaxLen - FileRequest$ and Fields."
    },
    "DEFTYPE": {
        "prefix": "DEFTYPE",
        "body": "DEFTYPE .Typename [Var[,Var...]]",
        "description": "DEFTYPE may be used to declare a list of variables as being of a particular type. In this case, Var parameters must be supplied. DEFTYPE may also be used to select a default variable type for future 'unknown' variables. Unknown variables are variables created with no Typename specifier. In this case, no Var parameters are supplied."
    },
    "NEWTYPE": {
        "prefix": "NEWTYPE",
        "body": [
            "NEWTYPE .Typename",
            "\tField1.q",
            "End NEWTYPE"
        ],
        "description": "NEWTYPE creates a custom variable type and must be followed by a list of entry names separated by ':' and/or newlines. NEWTYPE terminates using End NEWTYPE."
    },
    "SizeOf": {
        "prefix": "SizeOf",
        "body": "SizeOf .Typename [,Entrypath]",
        "description": "SizeOf allows you to determine the amount of memory, in bytes, a particular variable type takes up. SizeOf may also be followed by an optional Entrypath, in which case the offset from the start of the type to the specified entry is returned."
    },
    "Dim": {
        "prefix": "Dim",
        "body": "Dim ArrayName [List] (Dimension1[,Dimension2...])",
        "description": "Dim is used to initialize a BASIC array. Blitz supports 2 array types: simple arrays and list arrays. The ptional List parameter, if present, denotes a list array. Simple arrays are identical to standard BASIC arrays, and may be of any number dimensions. List arrays may be of only 1 dimension."
    },
    "ResetList": {
        "prefix": "ResetList",
        "body": "ResetList ArrayName()",
        "description": "ResetList is used in conjunction with a list array to prepare the list array for NextItem processing. After executing a ResetList, the next Nextitem executed will set the list array's 'current element' pointer to the list array's very first."
    },
    "AddFirst": {
        "prefix": "AddFirst",
        "body": "AddFirst (ArrayName())",
        "description": "AddFirst function allows you to insert an array list item at the beginning of an array list. AddFirst returns a true/false value reflecting whether or not there was enough room in the array list to add an element. If an array element was available, AddFirst returns a true value (-1), and sets the list array's 'current item' pointer to the item added. If no array element was available, AddFirst returns false (0)."
    },
    "AddLast": {
        "prefix": "AddLast",
        "body": "AddLast (ArrayName())",
        "description": "AddLast function allows you to insert an array list item at the end of an array list. AddLast returns a true/false value reflecting whether or not there was enough room in the array list to add an element. If an array element was available, AddLast returns a true value (-1), and sets the list array's 'current item' pointer to the item added. If no array element was available, AddLast returns false (0)."
    },
    "AddItem": {
        "prefix": "AddItem",
        "body": "AddItem (ArrayName())",
        "description": "AddItem function allows you to insert an array list item after the list array's 'current' item. AddItem returns a true/false value reflecting whether or not there was enough room in the array list to add an element. If an array element was available, Additem returns a true value (-1), and sets the list array's 'current item' pointer to the item added. If no array element was available, Additem returns false (0)."
    },
    "KillItem": {
        "prefix": "KillItem",
        "body": "KillItem ArrayName()",
        "description": "KillItem deletes the specified list array's current item. After executing KillItem, the list array's 'current item' pointer will be set to the item before the item deleted."
    },
    "PrevItem": {
        "prefix": "PrevItem",
        "body": "PrevItem (ArrayName())",
        "description": "PrevItem will set the specified list array's 'current item' pointer to the item before the list array's old current item. This allows for 'backwards' processing of a list array. Previtem returns a true/false value reflecting whether or not there actually was a previous item. If a previous item was available, PrevItem will return true (-1). Otherwise, PrevItem will return false (0)"
    },
    "NextItem": {
        "prefix": "NextItem",
        "body": "NextItem (ArrayName())",
        "description": "NextItem will set the specified list array's 'current item' pointer to the item after the list array's old current item. This allows for 'forwards' processing of a list array. Nextitem returns a true/false value reflecting whether or not there actually was a next item available or not. If an item was available, Nextitem will return true (-1). Otherwise, Nextitem will return false (0)."
    },
    "FirstItem": {
        "prefix": "FirstItem",
        "body": "FirstItem (ArrayName())",
        "description": "Executing Firstitem will set the specified list array's 'current item' pointer to the very first item in the list array. If there are no items in the list array, Firstitem will return false (0) otherwise, Firstitem will return true (-1)."
    },
    "LastItem": {
        "prefix": "LastItem",
        "body": "LastItem (ArrayName())",
        "description": "Executing Lastitem will set the specified list array's 'current item' pointer to the very last item in the list array. If there are no items in the list array, Lastitem will return false (0), otherwise Lastitem will return true (-1)."
    },
    "PushItem": {
        "prefix": "PushItem",
        "body": "PushItem ArrayName()",
        "description": "Executing Pushitem causes the specified list array's 'current item' pointer to be pushed onto an internal stack. This pointer may be later recalled by executing Popitem. The internal item pointer stack is set for up to 8 'pushes'."
    },
    "PopItem": {
        "prefix": "PopItem",
        "body": "PopItem ArrayName()",
        "description": "Popitem 'pops' or 'recalls' a previously pushed current item pointer for specified list array. Arrayname() must match the arrayname of most recently executed Pushitem."
    },
    "ItemStackSize": {
        "prefix": "ItemStackSize",
        "body": "ItemStackSize MaxItems()",
        "description": "ItemStackSize determines how many 'list' items may be pushed (using Pushltem), before items must be 'Pop'ped off again. For example, executing ItemStackSize 1000 will allow you to push up to 1000 list items before you run out of item stack space."
    },
    "SortList": {
        "prefix": "SortList",
        "body": "SortList Arrayname()",
        "description": "SortList command is used to rearrange the order of elements in a Blitz linked list. Order in which the items are sorted depends on the first field of the linked list type which must be a single integer word."
    },
    "Sort": {
        "prefix": "Sort",
        "body": "Sort Arrayname()",
        "description": "Sort will cause the specified array to be sorted. The direction of the sort may be specified using either the SortUp or SortDown commands. Default direction used for sorting is ascending - ie: array elements are sorted into a 'low to high' order."
    },
    "SortUp": {
        "prefix": "SortUp",
        "body": "SortUp",
        "description": "SortUp is used to force the Sort command to sort arrays into ascending order. Means that after being sorted, an array's contents will be ordered in a 'low to high' manner."
    },
    "SortDown": {
        "prefix": "SortDown",
        "body": "SortDown",
        "description": "SortDown is to force the Sort command to sort arrays into descending order. Means that, after being sorted, an array's contents will be ordered in a 'high to low' manner."
    },
    "Print": {
        "prefix": "Print",
        "body": "Print Expression[,Expresion...]",
        "description": "Print allows you to output either strings or numeric values to current output channel. Commands such as WindowOutput or BitMapOutput may be used to alter the current output channel."
    },
    "NPrint": {
        "prefix": "NPrint",
        "body": "Print Expression[,Expresion...]",
        "description": "NPrint allows you to output either strings or numeric values to the current output channel. Commands such as WindowOutput or BitMapOutput may be used to alter the current output channel. After all Expressions have been output, NPrint automatically prints a newline char."
    },
    "Format": {
        "prefix": "Format",
        "body": "Format FormatString",
        "description": "Format allows you to control the output of any numeric values by the Print or NPrint commands. FormatString is an 80 character or less string expression used for formatting information by the Print command. Special characters in FormatString are used to perform special formatting functions."
    },
    "FloatMode": {
        "prefix": "FloatMode",
        "body": "FloatMode Mode",
        "description": "FloatMode allows you to control how floating point numbers are output by the Print or NPrint commands."
    },
    "Data": {
        "prefix": "Data",
        "body": "Data [.Type] Item[,Item...]",
        "description": "Data statement allows to include pre-defined values in programs.'data items' may be transferred into variables using Read statement. When data is read into variables,the Type of the data being read MUST match the type of the variable it is being read into."
    },
    "Read": {
        "prefix": "Read",
        "body": "Read Var[,Var...]",
        "description": "Read is used to transfer items in Data statements into variables. Data is transferred sequentially into variables through what is known as a 'date pointer'. When a piece of data is read, data pointer is incremented to point at the next piece of data. Data pointer may be set to point to a particular piece of data using the Restore command."
    },
    "Restore": {
        "prefix": "Restore",
        "body": "Restore [Program Label]",
        "description": "Restore allows you to set Blitz's internal 'data pointer' to a particular piece of data after executing a Restore. The first item of data following specified Program Label will become the data to be read when the next Read command is executed. Restore with no parameters will reset data pointer to very first piece of data in program."
    },
    "Edit$": {
        "prefix": "Edit$",
        "body": "Edit$([DefaultString$],Characters)",
        "description": "Edit$ is Blitz's standard text input command. When used with Window and BitMap Input Edit$ causes the optional DefaultString$ and a cursor to be printed to display. It then waits for the user to hit RETURN. Edit$ returns the text entered by program user as a string of character. During FileInput Edit$ reads the next n characters from the open file or until the next endofline character (chr$(10)). To read data from files that is not standard ascii (ignore EOL terminators) Inkey$ should be used instead of Edit$. Characters specifies a maximum number of allowable characters for input. This is extremely useful in preventing Edit$ from destroying display contents."
    },
    "Edit": {
        "prefix": "Edit",
        "body": "Edit([DefaultValue],Characters)",
        "description": "Edit is Blitz's standard numeric input command. The same characteristics apply as those for Edit$ however Edit of course only accepts numeric input."
    },
    "Inkey$": {
        "prefix": "Inkey$",
        "body": "Inkey$[(Characters)]",
        "description": "Inkey$ is used to collect one or more characters from the current input channel. Current input channel may be selected using commands such as WindowInput, Filelnput or BitMapInput. Inkey$ MAY NOT be used from Defaultinput input channel as CLI does not pass input back to the program until the user hits return. Characters refers to the number of characters to collect. The default is one character."
    },
    "DefaultInput": {
        "prefix": "DefaultInput",
        "body": "DefaultInput",
        "description": "Defaultinput causes all future Edit$ and Inkey$ functions to receive their input from CLI window the Blitz program was run from. This is the default input channel used when a Blitz program is first run"
    },
    "DefaultOutput": {
        "prefix": "DefaultOutput",
        "body": "DefaultOutput",
        "description": "DefaultOutput cause all future Print statements to send their output to CLI window the Blitz program was run from. This is the default output channel used when a Blitz program is first run."
    },
    "FileRequest$": {
        "prefix": "FileRequest$",
        "body": "FileRequest$(Title$, Pathname$, Filename$)",
        "description": "FileRequest$ function will open up a standard Amiga-style file requester on currently used screen. Program flow will halt until user either selects a file, or hits requester's 'Cancel' button. If a file was selected, FileRequest$ will return the full file name as a string. If 'Cancel' was selected, FileRequest$ will return a null (empty) string. Title$ may be any string expression to be used as a title for the file requester. Pathname$ MUST be a string variable with a MaxLen of at least 160. Filename$ MUST be a string variable with a MaxLen of at least 64."
    },
    "PopInput": {
        "prefix": "PopInput",
        "body": "PopInput",
        "description": "After input has been re-directed (eg using WindowInput/Filelnput), Popinput may be used to return the channel to it's previous condition."
    },
    "PopOutput": {
        "prefix": "PopOutput",
        "body": "PopOutput",
        "description": "After output has been re-directed (eg using WindowOutput/FileOutput), PopOutput may be used to return the channel to it's previous condition."
    },
    "JoyX": {
        "prefix": "JoyX",
        "body": "JoyX(Port)",
        "description": "Joyx will return the left/right status of a joystick plugged into the specified port. Port must be either 0 or 1, 0 being the port the mouse is normally plugged into. If the joystick is held to the left, Joyx will return -1. If the joystick is held to the right, Joyx will return 1. If the joystick is held neither left or right, Joyx will return 0."
    },
    "JoyY": {
        "prefix": "JoyY",
        "body": "JoyY(Port)",
        "description": "Joyy will return the up/down status of a joystick plugged into the specified port. Port must be either 0 or 1, 0 being the port the mouse is normally plugged into. If the joystick is held upwards, Joyy will return -1. If the joystick is held downwrads, Joyy will return 1. If the joystick is held neither upwards or downwards, Joyy will return 0."
    },
    "JoyR": {
        "prefix": "JoyR",
        "body": "JoyR(Port)",
        "description": "Joyr may be used to determine the rotational direction of a joystick plugged into the specified port. Port must be either 0 or 1, port 0 being the port the mouse is normally plugged into. Joyr returns a value from 0 through 8 based on the following table:"
    },
    "JoyB": {
        "prefix": "JoyB",
        "body": "JoyB(Port)",
        "description": "Joyb read button status of the device plugged into specified port. Port must be either 0 or 1, 0 being the port where mouse is normally plugged into. If left button is pressed, Joyb will return 1. If right button is pressed, Joyb will return 2. If both buttons are pressed, Joyb will return 3. If no buttons are pressed, Joyb will return 0."
    },
    "GameB": {
        "prefix": "GameB",
        "body": [
            "CD32_Buttons = GameB(Port)",
            "CD32_Play = CD32_Buttons & 1 = 1",
            "CD32_Reverse = CD32_Buttons & 2 = 2",
            "CD32_Forward = CD32_Buttons & 4 = 4",
            "CD32_Green = CD32_Buttons & 8 = 8",
            "CD32_Yellow = CD32_Buttons & 16 = 16",
            "CD32_Red = CD32_Buttons & 32 = 32",
            "CD32_Blue = CD32_Buttons & 64 = 64"
        ],
        "description": "GameB returns the button states of CD32 style game controllers. The values of all buttons pressed are added together to make up the value returned by GameB. To check a certain button is down a logical AND should be performed, buttonvalue AND returnvalue will evaluate to 0 if the button is not held down."
    },
    "OpenFile": {
        "prefix": "OpenFile",
        "body": [
            "if OpenFile(File#,Filename$)",
            "\t;Do your file handling here.",
            "\tCloseFile File#",
            "else",
            "\t;The file was not successfully opened. Do your error handling here.",
            "endif"
        ],
        "description": "OpenFile attempts to open the file specified by Filename$. If file was successfully opened, OpenFile will return true (-1), otherwise, OpenFile will return false (0). Files opened using OpenFile may be both written to and read from. If the file specified by Filename$ did not already exist before the file was opened, it will be created by OpenFile. Files opened with OpenFile are intended for use by the random access file commands, although it is quite legal to use these files in a sequential manner."
    },
    "ReadFile": {
        "prefix": "ReadFile",
        "body": [
            "if ReadFile(File#,Filename$)",
            "\t;Do your file handling here.",
            "\tCloseFile File#",
            "else",
            "\t;The file was not successfully opened. Do your error handling here.",
            "endif"
        ],
        "description": "ReadFile opens an already existing file specified by Filename$ for sequential reading. If the specified file was successfully opened, ReadFile will return true (-1), otherwise ReadFile will return false (0). Once a file is open using ReadFile, FileInput may be used to read information from it."
    },
    "WriteFile": {
        "prefix": "WriteFile",
        "body": [
            "if WriteFile(File#,Filename$)",
            "\t;Do your file handling here.",
            "\tCloseFile File#",
            "else",
            "\t;The file was not successfully opened. Do your error handling here.",
            "endif"
        ],
        "description": "WriteFile creates a new file, specified by Filename$ for the purpose of sequential file writing. If the file was successfully opened, WriteFile will return true (-1), otherwise WriteFile will return false (0). A file opened using WriteFile may be written to by using the FileOutput command."
    },
    "CloseFile": {
        "prefix": "CloseFile",
        "body": "CloseFile File#",
        "description": "CloseFile is used to close a file opened using one of the file open functions (FileOpen, ReadFile, WriteFile). This should be done to all files when they are no longer required."
    },
    "Fields": {
        "prefix": "Fields",
        "body": "Fields File#, Var[, Var...]",
        "description": "Fields set up fields of a random access file record. Once Fields is executed, Get and Put are used to read and write information to and from the file. The Var parameters specify a list of variables you wish to be either read from or written to the file. When a Put is executed the values held in these variables will be transferred to the file. When a Get is executed these variables will take on values read from the file. Any string variables in the variable list MUST have been initialized to contain a maximum number of characters. This is done using the MaxLen command. These string variables must NEVER grow to be longer than their defined maximum length."
    },
    "Put": {
        "prefix": "Put",
        "body": "Put File#,Record",
        "description": "Put is used to transfer the values contained in a Fields variable list to a particular record in a random access file. When using Put to increase size of a random access file, you may only add to the immediate end of file. For example, if you have a random access file with 5 records in it, it is illegal to put record number 7 to the file until record number 6 has been created. "
    },
    "Get": {
        "prefix": "Get",
        "body": "Get File#,Record",
        "description": "Get is to transfer information from a particular record of a random access file into a variable list set up by Fields command. Only records which also exist may be'got'. "
    },
    "FileOutput": {
        "prefix": "FileOutput",
        "body": "FileOutput File#",
        "description": "FileOutput causes output of all subsequent Print and NPrint commands to be sent to the specified sequential file. When the file is later closed, Print statements should be returned to an appropriate output channel (eg: DefaultOutput or WindowOutput)."
    },
    "FileInput": {
        "prefix": "FileInput",
        "body": "Filelnput File# ",
        "description": "FileInput command causes all subsequent Edit, Edit$ and Inkey$ commands to receive their input from the specified file. When file is later closed, input should be redirected to an appropriate channel (eg: DefaultInput or WindowInput). "
    },
    "FileSeek": {
        "prefix": "FileSeek",
        "body": "FileSeek File#,Position",
        "description": "FileSeek allows you to move to a particular point in the specified file. The first piece of data in a file is at position 0, the second at position 1 and so on. Position must not be set to a value greater than the length of the file. Used in conjunction with OpenFile and Lof, FileSeek may be used to 'append'to a file. "
    },
    "Lof": {
        "prefix": "Lof",
        "body": "Lof(File#)",
        "description": "Lof will return the length, in bytes, of the specified file. "
    },
    "Eof": {
        "prefix": "Eof",
        "body": "Eof (File#)",
        "description": "Eof function allows you to determine if you are currently positioned at the end of the specified file. If so, Eof will return true (-1), otherwise Eof will return false (0). If you are at the end of a file, any further writing to the file will increase it's length, while any further reading from the file will cause an error. "
    },
    "Loc": {
        "prefix": "Loc",
        "body": "Loc (File#)",
        "description": "Loc may be used to determine your current position in the specified file. When a file is first opened, you will be at position 0 in the file DosBuffLen Bytes All Blitz file handling is done through the use of special buffering routines. This is done to increase the speed of file handling, especially in the case of sequential files. Initially, each file opened is allocated a 2048 byte buffer. However, if memory is tight this buffer size may be lowered using the DosBuffLen command. "
    },
    "KillFile": {
        "prefix": "KillFile",
        "body": "KillFile Filename$",
        "description": "KillFile command will simply attempt to delete the specified file. No error will be returned if the file could not be deleted. CatchDosErrs Whenever you are executing AmigaDos I/O (for example, reading or writing a file), there is always the possibility of something going wrong (for example, disk not inserted... read/write error etc.). Normally, when such problems occur, AmigaDos displays a suitable requester on the WorkBench window. However, by executing CatchDosErrs you can force such requesters to open on a Blitz window. The window you wish dos error requesters to open on should be the currently used window at the time CatchDosErrs is executed. "
    },
    "ReadMem": {
        "prefix": "ReadMem",
        "body": "ReadMem File#,Address,Length",
        "description": "ReadMem allows to read a number of bytes, determined by Length, into an absoulte memory location, determined by Address, from an open file specified by File#. Be careful using ReadMem, as writing to absolute memory may have serious consequences if you don't known what you're doing! "
    },
    "WriteMem": {
        "prefix": "WriteMem",
        "body": "WriteMem File#,Address,Length",
        "description": "WriteMem allows you to write a number of bytes, determined by Length, from an absolute memory location, determined by Address to an open file specified by File#. "
    },
    "Exists": {
        "prefix": "Exists",
        "body": "Exists (FileName$)",
        "description": "Exists actually returns the length of the file, unlike Lof() Exists() is for files that have not already been opened. If 0 the file either does not exist or is empty or is perhaps not a file at all! Hmmm, anyway the following poke turns off the \"Please Insert Volume Blah:\" requester so you can use Exists to wait for disk changes: Poke.l Peek.l(Peek.l(4)+276)+184,-1 ILBMlnfo Filename$ ILBMInfo examines an ILBM file. Once ILBMInfo has been executed. ILBMWidth, ILBMHeight and ILBMDepth examines properties of the image contained in file "
    },
    "ILBMWidth": {
        "prefix": "ILBMWidth",
        "body": "ILBMWidth",
        "description": "ILBMWidth will return the width (pixels) of an ILBM image examined with ILBMInfo. "
    },
    "ILBMHeight": {
        "prefix": "ILBMHeight",
        "body": "ILBMHeight",
        "description": "ILBMHeight will return the height (pixels) of an ILBM image examined with ILBMInfo. "
    },
    "ILBMDepth": {
        "prefix": "ILBMDepth",
        "body": "ILBMDepth",
        "description": "ILBMDepth will return the depth (bitplanes) of ILBM image examined with ILBMInfo. "
    },
    "ILBMViewMode": {
        "prefix": "ILBMViewMode",
        "body": "ILBMViewMode",
        "description": "ILBMViewMode returns the viewmode of the file that was processed by ILBMInfo. This is useful for opening a screen in the right mode before using LoadScreen etc. Different values of ViewMode are as follows (add/or them for different combinations): Mode Value HiRes 32768 Ham 2048 HalfBrite 128 Interlace 4 LoRes 0 "
    },
    "True": {
        "prefix": "True",
        "body": "True",
        "description": "True is a system constant with a value of -1. "
    },
    "False": {
        "prefix": "False",
        "body": "False",
        "description": "False is a system constant with a value of 0. NTSC This function returns 0 if the display is currently in PAL mode, or -1 if currently in NTSC mode. This may be used to write software which dynamically adjusts itself to different versions of the Amiga computer. "
    },
    "DispHeight": {
        "prefix": "DispHeight",
        "body": "DispHeight",
        "description": "DispHeight will return 256 if executed on a PAL Amiga or 200 if on an NTSC Amiga. This allows programs to open full sized screens, windows,etc on any Amiga "
    },
    "VPos": {
        "prefix": "VPos",
        "body": "VPos",
        "description": "VPos returns video's beam vertical position. Useful in both highspeed animation where screen update may need to be synced to a certain video beam position (not just the top of frame as with VWait) and for a fast random member generator in non frame- synced applications. "
    },
    "Abs": {
        "prefix": "Abs",
        "body": "Abs(Expression)",
        "description": "Abs (Expression) This function returns the positive equivalent of Expression. "
    },
    "Frac": {
        "prefix": "Frac",
        "body": "Frac (Expression)",
        "description": "Frac() returns the fractional part of Expression. Int (Expression) This returns the Integer part (before the decimal point) of Expression. "
    },
    "Int": {
        "prefix": "Int",
        "body": "Int (Expression)",
        "description": "Int (Expression) This returns the Integer part (before the decimal point) of Expression. "
    },
    "QAbs": {
        "prefix": "QAbs",
        "body": "QAbs (Quick)",
        "description": "QAbs works just like Abs except that the value it accepts is a Quick. This enhances the speed at which the function executes quite dramatically. Of course you are limited by the restrictions of the quick type of value. "
    },
    "QFrac": {
        "prefix": "QFrac",
        "body": "QFrac (Ouick)",
        "description": "QFrac() returns the fractional part of a quick value. It works like Frac() but accepts a quick value as it's argument. It´s faster than Frac() but has normal quick value limits. "
    },
    "QLimit": {
        "prefix": "QLimit",
        "body": "QLimit (Quick,Low,High)",
        "description": "QLimit is used to limit the range of a quick number. If Quick is greater than or equal to Low, and less than or equal to High, the value of Quick is returned. If Quick is less than Low, then Low is returned. If Quick is greater than High, then High is returned. "
    },
    "QWrap": {
        "prefix": "QWrap",
        "body": "QWrap(Ouick,Low,High)",
        "description": "QWrap will wrap the result of the Quick expression if Quick is greater than or equal to high, or less than low. If Quick is less than Low, then Quick- Low+High is returned. If Quick is greater than or equal to High, then Quick-High+Low is returned Rnd [(Range)] This function returns a random number. If Range is not specified then a random decimal is returned between 0 and 1. If Range is specified, then a decimal value between 0 and Range is returned. "
    },
    "Sgn": {
        "prefix": "Sgn",
        "body": "Sgn(Expression)",
        "description": "Sgn returns the sign of Expression. If Expression is less than 0, then -1 is returned. If Expression = 0 then 0 is returned. If Expression is > 0 then 1 is returned. "
    },
    "Cos": {
        "prefix": "Cos",
        "body": "Cos(Float) ",
        "description": "Cos() returns the Cosine of the value Float. Sin(Float) This returns the Sine of the value Float. Tan (Float) This returns the Tangent of the value Float. ACos (Float) This returns the ArcCosine of the value Float. ASin (Float) This returns the ArcSine of the value Float. ATan (Float) This returns the ArcTangent of the value Float. HCos (Float) This returns the hyperbolic Cosine of the value Float. HSin (Float) This returns the hyperbolic Sine of the value Float. HTan (Float) This returns the hyperbolic Tangent of the value Float. Exp (Float) This returns e raised to the power of Float. Sqr (Float) This returns the square root of Float. Log10 (Float This returns the base 10 logarithm of Float. Log (Float) This returns the natural (base e) logarithm of Float. "
    },
    "QAngle": {
        "prefix": "QAngle",
        "body": "QAngle(SrcX,SrcY,DestX,DestY)",
        "description": "QAngle returns the angle between the two 2D coordinates passed. The angle.q returned is a value from 0-1, 1 representing 360 degrees in standard polar geometry. Left$ (String$,Length) This function returns the Length leftmost characters of string String$. "
    },
    "Right$": {
        "prefix": "Right$",
        "body": "Right$(String$,Length)",
        "description": "Right$() returns the rightmost Length characters from string String$. Mid$ (String$,Startchar[ Length]) This function returns Length characters of string String$ starting at character Startchar. If the optional Length parameter is omitted, then all characters from Startchar up to the end of String$ will be returned. "
    },
    "Hex$": {
        "prefix": "Hex$",
        "body": "Hex$(Expression)",
        "description": "Hex$() returns an 8 character string equivalent to hexadecimal representation of Expression. "
    },
    "Bin$": {
        "prefix": "Bin$",
        "body": "Bin$(Expression)",
        "description": "Bin$() returns a 32 character string equivalent to a binary representation of Expression. "
    },
    "Chr$": {
        "prefix": "Chr$",
        "body": "Chr$(Expression)",
        "description": "Chr$ returns a one character string equivalent to the ASCII character Expression.Ascii is a standard way of coding the characters used by the computer display. "
    },
    "Asc": {
        "prefix": "Asc",
        "body": "Asc(String$)",
        "description": "Asc() returns the ASCII value of the first characters in the string String$."
    },
    "String$": {
        "prefix": "String$",
        "body": "String$(String$,Repeats)",
        "description": "This function will return a string containing Repeats sequential occurrences of the string String$. "
    },
    "Instr": {
        "prefix": "Instr",
        "body": "Instr(String$,Findstring$[,Startpos])",
        "description": "Instr attempts to locate FindString$ within String$. If a match is found, returns the character position of the first matching character. If no match is found, returns 0 The optional Startpos parameter allows you to specify a starting character position for the search. "
    },
    "Replace$": {
        "prefix": "Replace$",
        "body": "Replace$(String$,Findstring$,Replacestring$)",
        "description": "Replace$() will search the string String$ for any occurrences of the string Findstring$ and replace it with the string Replacestring$. "
    },
    "Mki$": {
        "prefix": "Mki$",
        "body": "Mki$(Integer)",
        "description": "This will create a two byte character string, given the two byte numeric value Numeric. Mki$ is often used before writing integer values to sequential files to save disk space. When the file is later read in, Cvi may be used to convert the string back to an integer. "
    },
    "Mkl$": {
        "prefix": "Mkl$",
        "body": "Mkl$ Long)",
        "description": "This will create a four byte character string, given the four byte numeric value Long. Mkl$ is often used when writing long values to sequential files to save disk space. When the file is later read in, Cvl may be used to convert the string back to a long. ill create a four byte character string, given the four byte numeric value Quick. "
    },
    "Mkq$": {
        "prefix": "Mkq$",
        "body": "Mkq$(Quick)",
        "description": "Mkq$ (Quick) This will create a four byte character string, given the four byte numeric value Quick. Mkq$ is often used when writing quick values to sequential files to save disk space. When the file is later read in, Cvq may be used to convert the string back to a quick. "
    },
    "Cvi": {
        "prefix": "Cvi",
        "body": "Cvi (String$)",
        "description": "Cvi returns an integer value equivalent to the left 2 characters of String$. This is the logical opposite of Mki$. "
    },
    "Cvl": {
        "prefix": "Cvl",
        "body": "Cvl (String$)",
        "description": "Cvl returns a long value equivalent to the left 4 characters of String$. This is the logical opposite of Mkl$. "
    },
    "Cvq": {
        "prefix": "Cvq",
        "body": "Cvq (String$)",
        "description": "Cvq returns a quick value equivalent to the left 4 characters of String$. This is the logical opposite of Mkq$. "
    },
    "Len": {
        "prefix": "Len",
        "body": "Len (String$)",
        "description": "Len returns the length of the string String$ "
    },
    "UnLeft$": {
        "prefix": "UnLeft$",
        "body": "UnLeft$ (String$,Length)",
        "description": "UnLeft$() removes the rightmost Length characters from the string String$. "
    },
    "UnRight$": {
        "prefix": "UnRight$",
        "body": "UnRight$ (String$,Length)",
        "description": "UnRight$() removes the leftmost Length characters from the string String$. "
    },
    "StripLead$": {
        "prefix": "StripLead$",
        "body": "StripLead$ (String$, Expression)",
        "description": "StripLead$ removes all leading occurrences of the ASCII character specified by Expression from the string String$. "
    },
    "StripTrail$": {
        "prefix": "StripTrail$",
        "body": "StripTrail$ (String$, Expression)",
        "description": "StripTrail$ removes all trailing occurrences of the ASCII character specified by Expression from the string String$. LSet$ (String$, Characters) This function returns a string of Characters characters long. The string String$ will be placed at the beginning of this string. If String$ is shorter than Characters the right hand side is padded with spaces. If it is longer, it will be truncated. RSet$ (String$, Characters) This function returns a string of Characters characters long. The string String$ will be placed at end of this string. If String$ is shorter than Characters the left hand side is padded with spaces. If it is longer, it will be truncated. Centre$ (String$,Characters) This function returns a string of Characters characters long. The string String$ will be centered in the resulting string. If String$ is shorter than Characters the left and right sides will be padded with spaces. If it is longer, it will be truncated on either side. LCase$ (String$) This function returns the string String$ converted into lowercase. UCase$ (Siring$) This function returns the string String$ converted to uppercase. CaseSense On l Off Allows to control the searching mode used by the Instr and Replace$ functions. "
    },
    "CaseSense": {
        "prefix": "CaseSense",
        "body": "CaseSense On | Off",
        "description": "Allows to control the searching mode used by the Instr and Replace$ functions. CaseSense On indicates that an exact match must be found. CaseSense Off indicates that alphabetic characters may be matched even if they are not in the same case CaseSense On is the default search mode."
    },
    "Val": {
        "prefix": "Val",
        "body": "Val(String$)",
        "description": "This functions converts the string String$ into a numeric value and returns this value. When converting the string, the conversion will stop the moment either a non numeric value or a second decimal point is reached."
    },
    "Str$": {
        "prefix": "Str$",
        "body": "Str$(Expression)",
        "description": "This returns a string equivalent of the numeric value Expression. This now allows you to perform string operations on this string. If the Format command has been used to alter numeric output, this will be applied to the resultant string."
    },
    "UStr$": {
        "prefix": "UStr$",
        "body": "UStr$(Expression)",
        "description": "This returns a string equivalent of the numeric value Expression. This now allows you to perform string operations on this string. Unlike Str$, UStr$ is not affected by any active Format commands. "
    },
    "SystemDate": {
        "prefix": "SystemDate",
        "body": "SystemDate",
        "description": "SystemDate returns the system date as the number of days passed since 1/1/1978. "
    },
    "Date$": {
        "prefix": "Date$",
        "body": "Date$ (days)",
        "description": "Date$ converts the format returned by SystemDate (days passed since 1/1/1978) into a string format of dd/mm/yyyy or mm/dd/yyyy depending on the dateformat (defaults to 0) "
    },
    "NumDays": {
        "prefix": "NumDays",
        "body": "NumDays (date$)",
        "description": "Numdays converts a Date$ in the above format to the day count format, where numdays is the number of days since 1/1/1978. "
    },
    "DateFormat": {
        "prefix": "DateFormat",
        "body": "DateFormat format# 0 or 1",
        "description": "DateFormat configures the way both date$ and numdays treat a string representation of the date: 0=dd/mm/yyyy and 1=mm/dd/yyyy "
    },
    "Days": {
        "prefix": "Days",
        "body": "Days",
        "description": "Days Months and Years each return the particular value relevant to the last call to SystemDate. They are most useful for when the program needs to format the output of the date other than that produced by date$."
    },
    "WeekDay": {
        "prefix": "WeekDay",
        "body": "WeekDay",
        "description": "WeekDay returns which day of the week it is with Sunday=0 through to Saturday=6."
    },
    "Months": {
        "prefix": "Months",
        "body": "Months",
        "description": "See description of Days."
    },
    "Years": {
        "prefix": "Years",
        "body": "Years",
        "description": "See description of Days"
    },
    "Hours": {
        "prefix": "Hours",
        "body": "Hours",
        "description": "Hours, Mins and Secs return the time of day when SystemDate was last called."
    },
    "Mins": {
        "prefix": "Mins",
        "body": "Mins",
        "description": "Hours, Mins and Secs return the time of day when SystemDate was last called."
    },
    "Secs": {
        "prefix": "Secs",
        "body": "Secs",
        "description": "Hours, Mins and Secs return the time of day when SystemDate was last called. Secs Hours, Mins and Secs return the time of day when SystemDate was last called. WBWidth The functions WBWidth, WBHeight, WBDepth & WBViewMode return the width, height, depth & viewmode of the current WorkBench screen as configured by preferences. WBHeight See Description of WBWidth. WBDepth See Description of WBWidth. WBViewMode See Description of WBWidth. "
    },
    "WBWidth": {
        "prefix": "WBWidth",
        "body": "WBWidth",
        "description": "The functions WBWidth, WBHeight, WBDepth & WBViewMode return the width, height, depth & viewmode of the current WorkBench screen as configured by preferences. WBHeight See Description of WBWidth. WBDepth See Description of WBWidth. WBViewMode See Description of WBWidth. "
    },
    "WBHeight": {
        "prefix": "WBHeight",
        "body": "WBHeight",
        "description": "See Description of WBWidth."
    },
    "WBDepth": {
        "prefix": "WBDepth",
        "body": "WBDepth",
        "description": "See Description of WBWidth."
    },
    "WBViewMode": {
        "prefix": "WBViewMode",
        "body": "WBViewMode",
        "description": "See Description of WBWidth."
    },
    "Processor": {
        "prefix": "Processor",
        "body": "Processor",
        "description": "Processor returns the processor type in the computer on program is currently running. 0=68000 1=68010 2=68020 3=68030 4=68040"
    },
    "ExecVersion": {
        "prefix": "ExecVersion",
        "body": "ExecVersion",
        "description": "ExecVersion returns the relevant information about the system´s program is running on. 33=1.2 34=1.3 36=2.0 39=3.0 "
    },
    "USEPATH": {
        "prefix": "USEPATH",
        "body": "USEPATH Pathtext",
        "description": "USEPATH allows you to specify a 'shortcut' path when dealing with NEWTYPE variables."
    },
    "BLITZ": {
        "prefix": "BLITZ",
        "body": "BLITZ",
        "description": "The BLITZ directive is used to enter Blitz mode. For a full discussion on Amiga/Blitz mode, please refer to the programming chapter of the Blitz Programmers Guide. "
    },
    "AMIGA": {
        "prefix": "AMIGA",
        "body": "AMIGA",
        "description": "The AMIGA directive is used to enter Amiga mode. For a full discussion on Amiga/Blitz mode, please refer to the programming chapter of the Blitz Programmers Guide."
    },
    "QAMIGA": {
        "prefix": "QAMIGA",
        "body": "QAMIGA",
        "description": "The QAMIGA directive is used to enter Quick Amiga mode. For a full discussion on Amiga/Blitz mode, please refer to the programming chapter of the Blitz Programmers Guide. "
    },
    "INCLUDE": {
        "prefix": "INCLUDE",
        "body": "INCLUDE Filename",
        "description": "INCLUDE is a compile time directive which causes the specified file, Filename, to be compiled as part of the programs object code. The file must be in tokenised form (de: saved from the Blitz editor) - ascii files may not be INCLUDE'd. INCDIR may be used to specify a path for Filename. Filename may be optionally quote enclosed to avoid tokenisation problems. "
    },
    "XINCLUDE": {
        "prefix": "XINCLUDE",
        "body": "XINCLUDE Filenam",
        "description": "XINCLUDE stands for exclusive include. XINCLUDE works identically to INCLUDE with the exception that XlNCLUDE'd files are only ever included once. For example, if a program has 2 XINCLUDE statements with the same filename, only the first XINCLUDE will have any effect. "
    },
    "INCBIN": {
        "prefix": "INCBIN",
        "body": "INCBIN Filename",
        "description": "INCBIN allows you to include a binary file in your object code. This is mainly of use to assembler language programmers, as having big chunks of binary data in the middle of a BASIC program is not really a good idea. "
    },
    "INCDIR": {
        "prefix": "INCDIR",
        "body": "INCDIR Pathname",
        "description": "INCDIR may be used to specify a path for Filename. Filename may be optionally quote enclosed to avoid tokenisation problems. The INCDIR command allows you to specify an AmigaDos path to be prefixed to any. Filenames specified by any of INCLUDE, XINCLUDE or INCBIN commands. "
    },
    "CNIF": {
        "prefix": "CNIF",
        "body": [
            "CNIF Constant Comparison Constant",
            "CEND"
        ],
        "description": "CNIF allows you to conditionally compile a section of program code based on a comparison of 2 constants. Comparison should be one of '<', '>', '=', '<>', '<=' or '>='. If the comparison proves to be true, then compiling will continue. If comparison is false no object code will be generated until a matching CEND is encountered. "
    },
    "CEND": {
        "prefix": "CEND",
        "body": "CEND",
        "description": "CEND marks the end of a block of conditionally compiled code. CEND must always appear somewhere following a CNIF or CSIF directive. "
    },
    "CSIF": {
        "prefix": "CSIF",
        "body": "CSIF \"String\" Comparison \"String\"",
        "description": "CSIF allows you to conditionally compile a section of program code based on a comparison of 2 literal strings. Comparison should be one of '<', '>', '=', '<>', '<=' or '>='. Both strings must be quote enclosed literal strings. If the comparison proves to be true, then compiling will continue as normal. If the comparison proves to be false, then no object code will be generated until a matching CEND is encountered. CSIF is of most use in macros for checking macro parameters. "
    },
    "CELSE": {
        "prefix": "CELSE",
        "body": "CELSE",
        "description": "CELSE may be used between a CNIF or CSIF, and a CEND to cause code to be compiled when a constant comparison proves to be false. "
    },
    "CERR": {
        "prefix": "CERR",
        "body": "CERR Errormessage",
        "description": "CERR allows a program to generate compile-time error messages. CERR is normally used in conjunction with macros and conditional compiling to generate errors when incorrect macro parameters are encountered. "
    },
    "Macro": {
        "prefix": "Macro",
        "body": [
            "Macro MacroName",
            "End Macro"
        ],
        "description": "Macro is used to declare the start of a macro definition. All text following Macro, up until the next End Macro, will be included in the macro's contents. "
    },
    "End Macro": {
        "prefix": "End Macro",
        "body": "End Macro",
        "description": "End Macro is used to finish a macro definition. Macro definitions are set up using the Macro command."
    },
    "Runerrson": {
        "prefix": "Runerrson",
        "body": "Runerrson",
        "description": "These two new compiler directives are for enabling and disabling error checking in different parts of the program, they override the settings in Compiler Options."
    },
    "Runerrsoff": {
        "prefix": "Runerrsoff",
        "body": "Runerrsoff",
        "description": "See description of Runerrson."
    },
    "Use": {
        "prefix": "Use",
        "body": "Use Objectname Object#",
        "description": "Use will cause the Blitz object specified by Objectname and Object# to become the currently used object. "
    },
    "Free": {
        "prefix": "Free",
        "body": "Free Objectname Object#",
        "description": "Frees a Blitz object. Any memory consumed by the object's existence will be free'd up, and in case of things such as windows and screens, the display may be altered. Attempting to free a non-existent object will have no effect."
    },
    "USED": {
        "prefix": "USED",
        "body": "USED ObjectName",
        "description": "Returns the currently used object number. Useful for routines which need to operate on currently used object, also interrupts should restore currently used object settings."
    },
    "Addr": {
        "prefix": "Addr",
        "body": "Addr Objectname(Object#)",
        "description": "Addr is a low-level function allowing advanced programmers the ability to find where a particular Blitz object resides in RAM. Apendix at the end lists all Blitz object formats."
    },
    "Maximum": {
        "prefix": "Maximum",
        "body": "Maximum Objectname",
        "description": "The Maximum function allows a program to determine the 'maximum' setting for a particular Blitz object. Maximum settings are entered into the OPTIONS requester, accessed through the 'COMPILER' menu of the Blitz editor. "
    },
    "DCB": {
        "prefix": "DCB",
        "body": "DCB [.Size] Repeats,Data",
        "description": "DCB stantd for 'define consistant block' .DCB allows you to insert a repeating series of the satire value into your assembler programs. "
    },
    "EVEN": {
        "prefix": "EVEN",
        "body": "EVEN",
        "description": "EVEN allows to word align Blitz's internal program counter. This may be necessary if a DC, DCB or DS statement has caused the program counter to be left at an odd address. "
    },
    "GetReg": {
        "prefix": "GetReg",
        "body": "GetReg 68000 Reg,Expression",
        "description": "GetReg allows you to tranfer the result of a BASIC expression to a 68000 register. The result of the expression will first be converted into a long value before being moved to the data register. GetReg should only be used to transfer expressions to one of the 8 data registers (d0-d7). GetReg will use the stack to temporarily store any registers used in calculation of the expression. "
    },
    "PutReg": {
        "prefix": "PutReg",
        "body": "PutReg 68000 Reg, Variable",
        "description": "PutReg may he used to transfer a vlue from any 68000 register (d0-d7/a0-a7) into a BASIC variable. If the specified variable is a string, long, float or quick, then all 4 bytes from the register will be transfered. If the specified variable is a word or a byte, then only the relevant low bytes will be transferred. "
    },
    "SysJsr": {
        "prefix": "SysJsr",
        "body": "SysJsr Routine",
        "description": "SysJsr allows you to call any of Blitz's system routines from your own program. Routine specifies a routine number to call. "
    },
    "TokeJsr": {
        "prefix": "TokeJsr",
        "body": "TokeJsr Token[,Form]",
        "description": "TokeJsr allows to call any of Blitz's library based routines. Token refers to either a token number, or an actual token name. Form refers to a particular form of the token. "
    },
    "ALibJsr": {
        "prefix": "ALibJsr",
        "body": "ALibJsr Token[,Form]",
        "description": "ALibJsr is only used when writing Blitz libraries. ALibJsr allows you to call a routine from another library from within your own library. Please refer to the Library Writing section of the programmers guide for more information on library writing. "
    },
    "BLibJsr": {
        "prefix": "BLibJsr",
        "body": "BLibJsr Token[,Form]",
        "description": "BLibJsr is only used when writing Blitz libraries. BLibJsr allows you to call a routine from another library from within your own library. Please refer to the Library Writing section of the programmers guide for more information on library writing. "
    },
    "AsmExit": {
        "prefix": "AsmExit",
        "body": "AsmExit",
        "description": "AsmExit is used to exit from functions and statements written in assembler.  Registers A4-A6 must be preserved in functions and statements written in assembler. "
    },
    "Poke": {
        "prefix": "Poke",
        "body": "Poke[.Type] Address,Data",
        "description": "The Poke command will place the specified Data into a absolute memory location specified by Address. The size of the Poke may be specified by the optional Type parameter. For example, to poke a byte into memory use Poke.b; to poke a word into memory use Poke.w; and to poke a long word into memory use Poke.l In addition, strings may be poked into memory by use of Poke$. This will cause the ascii code of all characters in the string specified by Data to be poked, byte by byte, into consecutive memory locations. An extra 0 is also poked past the end of the string. "
    },
    "Peek": {
        "prefix": "Peek",
        "body": "Peek[. Type](Address)",
        "description": "The Peek function returns the contents of the absolute memory location specified by Address. The optional Type parameter allows peeking of different sizes. For example, to peek a byte, you would use Peek.b; to peek a word, you would use Peek.w; and to peek a long, you would use Peek.l It is also possible to peek a string using Peek$. This will return a string of characters read trom consecutive memory locations until a byte of 0 is found. "
    },
    "Peeks$": {
        "prefix": "Peeks$",
        "body": "Peeks$(Address,length)",
        "description": "Peeks$ will return a string of characters corresponding to bytes peeked from consective memory locations starting at Address, and Length characters in length"
    },
    "Call": {
        "prefix": "Call",
        "body": "Call Address",
        "description": "Call make program flow to be transferred to the memory location specified by Address. NOTE that Call is for advanced programmers only, as incorrect use of Call can lead to severe problems - GURUS etc! A 68000 JSR instruction is used to transfer program flow, so an RTS may be used to transfer back to the Blitz program."
    },
    "Bank": {
        "prefix": "Bank",
        "body": "Bank(Bank#)",
        "description": "Returns the meniory location of the given memory Bank, replaces the older and more stupidly named BankLoc command."
    },
    "InitBank": {
        "prefix": "InitBank",
        "body": "InitBank Bank#,size,memtype",
        "description": "InitBank allocates a block of memory and assigns it to the Bank specified. The memtype is the same as the Amiga operating system memory flags: 1 = public  2 = chip 65536 = clear memory "
    },
    "BankSize": {
        "prefix": "BankSize",
        "body": "BankSize (Bank#)",
        "description": "BankSize returns the size of the memory block allocated for the specified Bank#. lnitBank Bank#,size,memtype  InitBank allocates a hlock ot memory and assigns it to the Bank specified. The memtype is the same as the Amiga operating system memory flags: 1 = public  2 = chip 65536 = clear memory "
    },
    "FreeBank": {
        "prefix": "FreeBank",
        "body": "FreeBank Bank#",
        "description": "FreeBank de-allocates any memory block allocated for the Bank specified."
    },
    "LoadBank": {
        "prefix": "LoadBank",
        "body": "LoadBank Bank#,FileName$[,MemType]",
        "description": "The LoadBank command has been modified, instead of having to initialise the bank before loading a file, LoadBank will now initialise the bank to the size of the file if it is not already large enough or has not been initialised at all. "
    },
    "SaveBank": {
        "prefix": "SaveBank",
        "body": "SaveBank Bank#,filename$",
        "description": "SaveBank will save the memory assigned to the Bank to the filename specified. "
    },
    "AllocMem": {
        "prefix": "AllocMem",
        "body": "AllocMem(size,type)",
        "description": "Unlike calling Exec's AllocMem_ command directly Blitz will automatically free any allocated memory when the program ends. Programmers are advised to use the InitBank command. Flags that can be used with the memory type parameter are: 1=public ;fast if present 2=chipmem 65536=clear ;clears all memory allocated with 0's"
    },
    "FreeMem": {
        "prefix": "FreeMem",
        "body": "FreeMem location,size",
        "description": "Used to free any memory allocated with the AllocMem command. "
    },
    "WBStartup": {
        "prefix": "WBStartup",
        "body": "WBStartup",
        "description": "By executing WBStartup at some point in your program, your program will be given the ability to run from Workbench. A program run from Workbench which does NOT include the WBStartup command will promptly crash if an attempt is made to run it from Workbench. "
    },
    "NumPars": {
        "prefix": "NumPars",
        "body": "NumPars",
        "description": "The NumPars function allows an executable file to determine how many parameters were passed to it by either Workbench or the CLI.  Parameters passed from the CLI are typed following the program name and separated by spaces. For example. let's say you have created an executable program called myprog, and run it trom the CLI in the following way: myprog filer Olle2 In this case, NumPars would return the value '2' - 'file1' and 'file2' beng the 2 parameters. Programs run from Workbench are only capable of picking up 1 parameter through the use of either the parameter file's 'Default Tool' entry in it's '.info' file, or by use of multiple selection through the 'Shift' key. If no parameters are supplied to an executable file, NumPars will return 0. During program development, the 'CLI Arguement' menu item in the 'COMPILER' menu allows you to test out CLI parameters. "
    },
    "Par$": {
        "prefix": "Par$",
        "body": "Par$ (Parameter)",
        "description": "Par$ return a striny equivalent to a parameter passed to an executable file through either the CLI or Workbench. Refer to NumPars for more information. "
    },
    "CloseEd": {
        "prefix": "CloseEd",
        "body": "CloseEd",
        "description": "CloseEd statetnent will cause the Blitz editor screen to 'close down' when programs are executed from within Blitz. This may be useful when writing programs which use a large amount of chip memory, as the editor screen itself occupies 40K of ChipMem. CloseEd will have no effect on executable files run outside of the Blitz environment. "
    },
    "NoCli": {
        "prefix": "NoCli",
        "body": "NoCli",
        "description": "NoCli will prevent the normal 'Default Cli' from opening when programs are executed from within Blitz. NoCli has no effect on executable files run outside Blitz environment"
    },
    "FromCLI": {
        "prefix": "FromCLI",
        "body": "FromCLI",
        "description": "FromCLI Returns TRUE (-1) if your program was run from CLI, or FALSE (0) if run from WB. "
    },
    "ParPath$": {
        "prefix": "ParPath$",
        "body": "ParPath$ (parameter,type)",
        "description": "ParPath$ returns the path that the parameter resides in, 'type' specifies how you want the path returned: 0 You want only the directory of the parameter returned.  1 You want the directory along with the parameter name returned. If you passed the parameter \"FRED\" to your program from WB, and FRED resides in directory \"work:mystuff/myprograms\" then ParPath$(0,0) will return \"work:mystuff/ myprograms\" , but ParPath$(0,1) will return \"work:mystuff/myprograms/FRED\". The way WB handles argument passing of directories is different to that of files. When a directory is passed as an argument, ArgsLib gets an empty string for the name, and the directory string holds the path to the passed directory AND the directory name itself. Slice Slice#, Y, Flags Slice#, Y, Width, Height, Flags, BitPlanes, Sprites, Colours, w1, w2 The Slice command is used to create a Blitz slice object. Slices are primarily of  use in Blitz mode, allowing you to create highly customized displays. In both forms of the Slice command, the Y parameter specifies the vertical pixel position of the top of the slice. A Y value of 44 will position slices at about the top of the display. In the first torm of the Slice command, Flags refers to the number of bitplanes in any bitmaps (the bitmap's depth) to be shown in the slice. This form of the Slice command will normally create a lo-res slice, however this may be changed to a hi-res slice by adding eight to the Flags parameter. For instance, a Flags value of tour will set up a lo-res, 4 bitplane (16 colour) slice, whereas a Flags value of ten will set up a hi- res, 2 bitplane (4 colour) slice. The width of a slice set up in this way will be 320 pixels for a lo-res slice, or 640 pixels for a hi-res slice. The height of a slice set up using this syntax will be 200 pixels on an NTSC Amiga, or 256 pixels on a PAL Amiga. The second form of the Slice command is far more versatile, albeit a little more complex. Width and Height allow you to use specific values for the slice's dimensions. These parameters are specified in pixel amounts. BitPlanes refers to the depth of any bitmaps you will be showing in this slice. Sprites refers to how many sprite channels should be available in this slice. Each slice may have up to eight sprite channels, allowing sprites to be 'multiplexed'. This is one way to overcome the Amiga's 'eight sprite limit'. It is recommended that the top-most slice be created with all 8 sprite channels, as this will prevent sprite flicker caused by unused sprites. Colours refers to how many colour palette entries should be available for this slice, and should not be greater than 32. Width1 and Width2 specify the width, in pixels, of any bitmaps to be shown in this slice. If a slice is set up to be a dual-playfield slice, Width1 refers to the width of the 'foreground' bitmap, and Width2 refers to the width of the 'background' bitmap. If a slice is NOT set up to be a dual-playfield slice, both Width1 and Width2 should be set to the same value. These parameters allow you to show bitmaps which are wider than the slice, introducing the ability to smooth scroll through large bitmaps. The Flags parameter has been lett to last because it is the most complex. Flags allows you control over many aspects of the slices appearance, and just what ettect the slice has. Here are some example settings for Flags: Flags Effect Max BitPlanes $ftf8 A Standard lo-res slice 6 $fft9  A Standard hi-res slice 4 $fita  A Lo-res, dual-playfield slice 6 $tfib  A Hi-res, dual-playfiled slice 4 $fffc  A HAM slice 6 WARNING - the next bit is definitely for the more advanced users out there! Knowledge of the following is NOT necessary to make good use of slices. Flags is actually a collection of individual bit-flags. The bit-flags control how the slices 'copper list' is created. Here is a list of the bitsnumbers and their effect: Bit# Effect 15 Create copper MOVE BPLCON0 14 Create copper MOVE BPLCON1 13 Create copper MOVE BPLCON2 12 Create copper MOVE DIWSTRT and MOVE DIWSTOP 10 Create copper MOVE DDFSTRT and MOVE DDFSTOP  8 Create copper MOVE BPL1MOD  7 Create copper MOVE BPL2MOD  4 Create a 2 line 'blank' above top of slice  3 Allow for smooth horizontal scrolling  2 HAM slice  1 Dual-playtield slice  0 Hi-res slice - default is lo-res Clever selection of these bits allows you to create 'minimal' slices which may only affect specific system registers. The BitPlanes parameter may also be modified to specify 'odd only' or 'even only' bitplanes. This is of use when using dual playfield displays, as it allowing you to create a mid display slice which may show a different foreground or background bitmap leaving the other intact. To specify creation of foreground bitplanes only, simply set bit 15 of the BitPlanes parameter. To specify creation of background bitplanes only, set bit 14 of the BitPlanes parameter "
    }
}