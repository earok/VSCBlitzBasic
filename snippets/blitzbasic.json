{
    "Goto": {
        "prefix": "Goto",
        "body": "Goto Label",
        "description": "Goto causes program flow to be transferred to the specified program label. This allows sections of a program to be 'skipped' or 'repeated'."
    },
    "Gosub": {
        "prefix": "Gosub",
        "body": "Gosub Label",
        "description": "Gosub operates in two steps. First, the location of the instruction following the Gosub is remembered in a special storage area (known as the 'stack'). Secondly, program flow is transferred to the specified Program Label. The section of program that program flow is transferred to is known as a subroutine' and should be terminated by a Return command."
    },
    "Return": {
        "prefix": "Return",
        "body": "Return",
        "description": "Return is used to return program flow to the instruction following the previously executed Gosub command. This allows the creation of 'subroutines' which may be called from various points in a program."
    },
    "On": {
        "prefix": "On",
        "body": "On Expression Goto|Gosub Label1 Label2...",
        "description": "If the specified Expression results in a 1, then the first Program Label will be branchedto. A result of 2 will cause the second Program Label to be branched to and so on. If the result of Expression is less than one, or not enough Program Labels are supplied, program flow will continue without a branch."
    },
    "End": {
        "prefix": "End",
        "body": "End",
        "description": "End will halt program flow completely. In case of programs run from Blitz editor, youwill be returned to editor. In case of executable files, will be returned to WB or CLI."
    },
    "Stop": {
        "prefix": "Stop",
        "body": "Stop",
        "description": "Stop command causes the Blitz Debugger to interrupt program flow. Place Stop commands in your code as breakpoints when debugging, ensure runtime errors areenabled. Click on Run from the debugger to continue program flow after a Stop."
    },
    "If": {
        "prefix": "If",
        "body": [
            "If Expression",
            "Endif"
        ],
        "description": "If allows execution of a section of program depending on the result of an expression. The Then command indicates only the rest of the line will be defined as the section ofcode to either execute or not. Without a Then the section of code will be defined asthat up to the EndIf command."
    },
    "Endif": {
        "prefix": "Endif",
        "body": "Endif",
        "description": "EndIf is used to terminate an 'If block'. An If block is begun by use of If statement without the then present. Please refer to If for more information on If blocks."
    },
    "Else": {
        "prefix": "Else",
        "body": "Else",
        "description": "Else may be used after an If to cause program instructions to be executed if the expression specified in the If proved to be false."
    },
    "While": {
        "prefix": "While",
        "body": [
            "While Expression",
            "Wend"
        ],
        "description": "While command is used to execute a series of commands repeatedly while the specified Expression proves to be true. The commands to be executed include all the commands following the While until the next matching Wend."
    },
    "Wend": {
        "prefix": "Wend",
        "body": "Wend",
        "description": "Wend is used in conjunction with While to determine a section of program to be executed repeatedly based upon the truth of an expression."
    },
    "Select": {
        "prefix": "Select",
        "body": [
            "Select Expression",
            " Case Expression",
            " Default",
            "End Select"
        ],
        "description": "Select examines and 'remembers' the result of the specified Expression. The Case commands may then be used to execute different sections of program code depending on the result of the expression in the Select line."
    },
    "Case": {
        "prefix": "Case",
        "body": "Case Expression",
        "description": "A Case is used following a Select to execute a section of program code when ,and only when, the Expression specified in the Case statement is equivalentto the Expression evaluated in the Select statement. If a Case statement is satisfied, program flow will continue until the next Case Default or End Select statement is encountered, at which point program flow will branch to the next matching End Select."
    },
    "Default": {
        "prefix": "Default",
        "body": "Default",
        "description": "A Default statement may appear following a series of Case statements to cause a section of code to be executed if NONE of the Case statements were satisfied."
    },
    "End Select": {
        "prefix": "End Select",
        "body": "End Select",
        "description": "End Select terminates a Select...Case...Case...Case sequence. If program flow hadbeen diverted through the use of a Case or Default statement, it will continue from the terminating End Select."
    },
    "For": {
        "prefix": "For",
        "body": [
            "For Var = Expression1 To Expression2 [Step Expression3]",
            "Next"
        ],
        "description": "The For statement initializes a For...Next loop. All For/Next loops must begin with a For statement, and must have a terminating Next statement further down the program.For..Next loops cause a particular section of code to be repeated a certain number oftimes. The For statement does most of the work in a For/Next loop. When For is executed, the variable specified by Var (known as the index variable) will be set to the value Expressionl. After this, the actual loop commences."
    },
    "Next": {
        "prefix": "Next",
        "body": "Next [var[,Var..]]",
        "description": "Next terminates a For..Next loop."
    },
    "Repeat": {
        "prefix": "Repeat",
        "body": [
            "Repeat",
            "Until Expression"
        ],
        "description": "Repeat is used to begin a Repeat...Until loop. Each Repeat statement in a program must have a corresponding Until further down the program. The purpose of Repeat/Until loops is to cause a section of code to be executed AT LEAST ONCE before a test is made to see if the code should be executed again"
    },
    "Until": {
        "prefix": "Until",
        "body": "Until Expression",
        "description": "Until is used to terminate a Repeat/Until loop. If Expression is true (non 0) program flow will continue from the command following Until. If Expression is false (0) program flow will go back to the corresponding Repeat,found further up the program"
    },
    "Forever": {
        "prefix": "Forever",
        "body": "Forever",
        "description": "Forever may be used instead of Until to cause a Repeat/Until loop to NEVER exit. Executing Forever is identical to executing 'Until 0'."
    },
    "Pop": {
        "prefix": "Pop",
        "body": "Pop Gosub|For|Select|If|While|Repeat",
        "description": "Sometimes, it may be necessary to exit from a particular type of program loop in order to transfer program flow to a different part of program. Pop must be included before the Goto which transfers program flow out from the inside of the loop. Actually, Pop is only necessary to prematurely terminate Gosubs, Fors and Selects. If, While and Repeat have been included for completeness but are not necessary."
    },
    "MouseWait": {
        "prefix": "MouseWait",
        "body": "MouseWait",
        "description": "MouseWait halts program until left mouse button is pushed. If left mouse is already held down when a MouseWait is executed, program will simply continue through. MouseWait should normally be used only for program testing purposes, as MouseWait severely slows down multi-tasking."
    },
    "VWait": {
        "prefix": "VWait",
        "body": "VWait [Frames]",
        "description": "VWait will cause program flow to halt until the next vertical blank occurs. Optional Frames parameter may be used to wait for a particular number of vertical blanks. VWait is especially useful in animation for synchrodizing display changes with the rate at which the display is physically redrawn by the monitor."
    },
    "Statement": {
        "prefix": "Statement",
        "body": [
            "Statement Procedurename{Parameters...}",
            " Statement Return",
            "End Statement"
        ],
        "description": "Statement declares all following code up to the next End Statement as being a 'statement type' procedure. Up to 6 Parameters may be passed to a statement in the form of local variables through which calling parameters are passed. In Blitz, all statements and functions must be declared before they are called."
    },
    "End Statement": {
        "prefix": "End Statement",
        "body": "End Statement",
        "description": "End Statement declares the end of a 'statement type' procedure definition. All statement type procedures must be terminated with an End Statement."
    },
    "Statement Return": {
        "prefix": "Statement Return",
        "body": "Statement Return",
        "description": "Statement Return may be used to prematurely exit from a 'statement type' procedure. Program flow will return to the command following the procedure call."
    },
    "Function": {
        "prefix": "Function",
        "body": [
            "Function[.type] Procedurename{Parameters...}",
            " Function Return Expression",
            "End Function"
        ],
        "description": "Function declares all following code up to the next End Function as being a function type procedure. The optional Type parameter may be used to determine what type of result is returned by the function. Type. If specified, must be one Blitz's 6 primitive variable types. If no Type is given, the current default type is used. Up to 6 parameters may be passed to a function in form of local variables through which calling parameters are passed. Functions may return values through the Function Return command. In Blitz, all statements and functions must be declared before they are called."
    },
    "End Function": {
        "prefix": "End Function",
        "body": "End Function",
        "description": "End Function declares the end of a 'function type' procedure definition. All function type procedures must be terminated with an End Function."
    },
    "Function Return": {
        "prefix": "Function Return",
        "body": "Function Return Expression",
        "description": "Function Return allows 'function type' procedures to return values to their calling expressions. Function type procedures are called from within Blitz expressions."
    },
    "Shared": {
        "prefix": "Shared",
        "body": "Shared Var[,Var...]",
        "description": "Shared is used to declare certain variables within a procedure definition as being global variables. Any variables appearing within a procedure definition that do n<>t appear in a Shared statement are, by default, local variables."
    },
    "SetInt": {
        "prefix": "SetInt",
        "body": [
            "SetInt Type",
            "End SetInt"
        ],
        "description": "Setint is used to declare a section of program code as 'interrupt' code. Often, when a computer program is running,an event of some importance takes place which must be processed immediately."
    },
    "End SetInt": {
        "prefix": "End SetInt",
        "body": "End SetInt",
        "description": "End SetInt must appear after a SetInt to signify the end of a section of interrupt handler code. Please refer to SetInt for more information of interrupt handlers."
    },
    "ClrInt": {
        "prefix": "ClrInt",
        "body": "ClrInt",
        "description": "ClrInt may be used to remove any interrupt handlers currently attached to specified interrupt Type. SetInt is used to attach interrupt handlers to particular interrupts."
    },
    "SetErr": {
        "prefix": "SetErr",
        "body": [
            "SetErr",
            "End SetErr"
        ],
        "description": "The SetErr command allows you to set up custom error handlers. Program code which appears after the SetErr command will be executed when any Blitz runtime errors are caused. Custom error code should be ended by an End SetErr."
    },
    "End SetErr": {
        "prefix": "End SetErr",
        "body": "End SetErr",
        "description": "End SetErr must appear following custom error handlers installed using SetErr. Please refer to SetErr tor more information on custom error handlers."
    },
    "ClrErr": {
        "prefix": "ClrErr",
        "body": "ClrErr",
        "description": "ClrErr may be used to remove a custom error handler set up using SetErr."
    },
    "ErrFail": {
        "prefix": "ErrFail",
        "body": "ErrFail",
        "description": "ErrFail may be used within custom error handlers to cause a 'normal' error. The error which caused the custom error handler to be executed will be reported and transfer will be passed to direct mode."
    },
    "Let": {
        "prefix": "Let",
        "body": "Let Var=Expression",
        "description": "Let is an optional command used to assign a value to a variable. Let must always be followed by a variable name and an expression.An equals sign ('=') is placed between the variable name and the expression. If the equals sign is omitted, then an opertor (eg: '+', '*') must appear between the variable name and the expression. In this case, the specified variable will be altered by the specified operator and expression."
    },
    "Exchange": {
        "prefix": "Exchange",
        "body": "Exchange Var Var",
        "description": "Exchange will 'swap' the values contained in the 2 specified variables. Exchange may only be used with 2 variables of the same type."
    },
    "MaxLen": {
        "prefix": "MaxLen",
        "body": "MaxLen StringVar=Expression",
        "description": "MaxLen sets aside a block of memory for a string variable to grow into. This is normally only necessary in the case of special Blitz commands which require this space to be present before execution. Currently, only 2 Blitz commands require the use of MaxLen - FileRequest$ and Fields."
    },
    "DEFTYPE": {
        "prefix": "DEFTYPE",
        "body": "DEFTYPE .Typename [Var[,Var...]]",
        "description": "DEFTYPE may be used to declare a list of variables as being of a particular type. In this case, Var parameters must be supplied. DEFTYPE may also be used to select a default variable type for future 'unknown' variables. Unknown variables are variables created with no Typename specifier. In this case, no Var parameters are supplied."
    },
    "NEWTYPE": {
        "prefix": "NEWTYPE",
        "body": [
            "NEWTYPE .Typename",
            "End NEWTYPE"
        ],
        "description": "NEWTYPE creates a custom variable type and must be followed by a list of entry names separated by ':' and/or newlines. NEWTYPE terminates using End NEWTYPE."
    },
    "SizeOf": {
        "prefix": "SizeOf",
        "body": "SizeOf .Typename [,Entrypath]",
        "description": "SizeOf allows you to determine the amount of memory, in bytes, a particular variable type takes up. SizeOf may also be followed by an optional Entrypath, in which case the offset from the start of the type to the specified entry is returned."
    },
    "Dim": {
        "prefix": "Dim",
        "body": "Dim ArrayName [List] (Dimension1[,Dimension2...])",
        "description": "Dim is used to initialize a BASIC array. Blitz supports 2 array types: simple arrays and list arrays. The ptional List parameter, if present, denotes a list array. Simple arrays are identical to standard BASIC arrays, and may be of any number dimensions. List arrays may be of only 1 dimension."
    },
    "ResetList": {
        "prefix": "ResetList",
        "body": "ResetList ArrayName()",
        "description": "ResetList is used in conjunction with a list array to prepare the list array for NextItem processing. After executing a ResetList, the next Nextitem executed will set the list array's 'current element' pointer to the list array's very first."
    },
    "AddFirst": {
        "prefix": "AddFirst",
        "body": "AddFirst (ArrayName())",
        "description": "AddFirst function allows you to insert an array list item at the beginning of an array list. AddFirst returns a true/false value reflecting whether or not there was enough room in the array list to add an element. If an array element was available, AddFirst returns a true value (-1), and sets the list array's 'current item' pointer to the item added. If no array element was available, AddFirst returns false (0)."
    },
    "AddLast": {
        "prefix": "AddLast",
        "body": "AddLast (ArrayName())",
        "description": "AddLast function allows you to insert an array list item at the end of an array list. AddLast returns a true/false value reflecting whether or not there was enough room in the array list to add an element. If an array element was available, AddLast returns a true value (-1), and sets the list array's 'current item' pointer to the item added. If no array element was available, AddLast returns false (0)."
    },
    "AddItem": {
        "prefix": "AddItem",
        "body": "AddItem (ArrayName())",
        "description": "AddItem function allows you to insert an array list item after the list array's 'current' item. AddItem returns a true/false value reflecting whether or not there was enough room in the array list to add an element. If an array element was available, Additem returns a true value (-1), and sets the list array's 'current item' pointer to the item added. If no array element was available, Additem returns false (0)."
    },
    "KillItem": {
        "prefix": "KillItem",
        "body": "KillItem ArrayName()",
        "description": "KillItem deletes the specified list array's current item. After executing KillItem, the list array's 'current item' pointer will be set to the item before the item deleted."
    },
    "PrevItem": {
        "prefix": "PrevItem",
        "body": "PrevItem (ArrayName())",
        "description": "PrevItem will set the specified list array's 'current item' pointer to the item before the list array's old current item. This allows for 'backwards' processing of a list array. Previtem returns a true/false value reflecting whether or not there actually was a previous item. If a previous item was available, PrevItem will return true (-1). Otherwise, PrevItem will return false (0)"
    },
    "NextItem": {
        "prefix": "NextItem",
        "body": "NextItem (ArrayName())",
        "description": "NextItem will set the specified list array's 'current item' pointer to the item after the list array's old current item. This allows for 'forwards' processing of a list array. Nextitem returns a true/false value reflecting whether or not there actually was a next item available or not. If an item was available, Nextitem will return true (-1). Otherwise, Nextitem will return false (0)."
    },
    "FirstItem": {
        "prefix": "FirstItem",
        "body": "FirstItem (ArrayName())",
        "description": "Executing Firstitem will set the specified list array's 'current item' pointer to the very first item in the list array. If there are no items in the list array, Firstitem will return false (0) otherwise, Firstitem will return true (-1)."
    },
    "LastItem": {
        "prefix": "LastItem",
        "body": "LastItem (ArrayName())",
        "description": "Executing Lastitem will set the specified list array's 'current item' pointer to the very last item in the list array. If there are no items in the list array, Lastitem will return false (0), otherwise Lastitem will return true (-1)."
    },
    "PushItem": {
        "prefix": "PushItem",
        "body": "PushItem ArrayName()",
        "description": "Executing Pushitem causes the specified list array's 'current item' pointer to be pushed onto an internal stack. This pointer may be later recalled by executing Popitem. The internal item pointer stack is set for up to 8 'pushes'."
    },
    "PopItem": {
        "prefix": "PopItem",
        "body": "PopItem ArrayName()",
        "description": "Popitem 'pops' or 'recalls' a previously pushed current item pointer for specified list array. Arrayname() must match the arrayname of most recently executed Pushitem."
    },
    "ItemStackSize": {
        "prefix": "ItemStackSize",
        "body": "ItemStackSize MaxItems()",
        "description": "ItemStackSize determines how many 'list' items may be pushed (using Pushltem), before items must be 'Pop'ped off again. For example, executing ItemStackSize 1000 will allow you to push up to 1000 list items before you run out of item stack space."
    },
    "SortList": {
        "prefix": "SortList",
        "body": "SortList Arrayname()",
        "description": "SortList command is used to rearrange the order of elements in a Blitz linked list. Order in which the items are sorted depends on the first field of the linked list type which must be a single integer word."
    },
    "Sort": {
        "prefix": "Sort",
        "body": "Sort Arrayname()",
        "description": "Sort will cause the specified array to be sorted. The direction of the sort may be specified using either the SortUp or SortDown commands. Default direction used for sorting is ascending - ie: array elements are sorted into a 'low to high' order."
    },
    "SortUp": {
        "prefix": "SortUp",
        "body": "SortUp",
        "description": "SortUp is used to force the Sort command to sort arrays into ascending order. Means that after being sorted, an array's contents will be ordered in a 'low to high' manner."
    },
    "SortDown": {
        "prefix": "SortDown",
        "body": "SortDown",
        "description": "SortDown is to force the Sort command to sort arrays into descending order. Means that, after being sorted, an array's contents will be ordered in a 'high to low' manner."
    },
    "Print": {
        "prefix": "Print",
        "body": "Print Expression[,Expresion...]",
        "description": "Print allows you to output either strings or numeric values to current output channel. Commands such as WindowOutput or BitMapOutput may be used to alter the current output channel."
    },
    "NPrint": {
        "prefix": "NPrint",
        "body": "Print Expression[,Expresion...]",
        "description": "NPrint allows you to output either strings or numeric values to the current output channel. Commands such as WindowOutput or BitMapOutput may be used to alter the current output channel. After all Expressions have been output, NPrint automatically prints a newline char."
    },
    "Format": {
        "prefix": "Format",
        "body": "Format FormatString",
        "description": "Format allows you to control the output of any numeric values by the Print or NPrint commands. FormatString is an 80 character or less string expression used for formatting information by the Print command. Special characters in FormatString are used to perform special formatting functions."
    },
    "FloatMode": {
        "prefix": "FloatMode",
        "body": "FloatMode Mode",
        "description": "FloatMode allows you to control how floating point numbers are output by the Print or NPrint commands."
    },
    "Data": {
        "prefix": "Data",
        "body": "Data [.Type] Item[,Item...]",
        "description": "Data statement allows to include pre-defined values in programs.'data items' may be transferred into variables using Read statement. When data is read into variables,the Type of the data being read MUST match the type of the variable it is being read into."
    },
    "Read": {
        "prefix": "Read",
        "body": "Read Var[,Var...]",
        "description": "Read is used to transfer items in Data statements into variables. Data is transferred sequentially into variables through what is known as a 'date pointer'. When a piece of data is read, data pointer is incremented to point at the next piece of data. Data pointer may be set to point to a particular piece of data using the Restore command."
    },
    "Restore": {
        "prefix": "Restore",
        "body": "Restore [Program Label]",
        "description": "Restore allows you to set Blitz's internal 'data pointer' to a particular piece of data after executing a Restore. The first item of data following specified Program Label will become the data to be read when the next Read command is executed. Restore with no parameters will reset data pointer to very first piece of data in program."
    },
    "Edit$": {
        "prefix": "Edit$",
        "body": "Edit$([DefaultString$],Characters)",
        "description": "Edit$ is Blitz's standard text input command. When used with Window and BitMap Input Edit$ causes the optional DefaultString$ and a cursor to be printed to display. It then waits for the user to hit RETURN. Edit$ returns the text entered by program user as a string of character. During FileInput Edit$ reads the next n characters from the open file or until the next endofline character (chr$(10)). To read data from files that is not standard ascii (ignore EOL terminators) Inkey$ should be used instead of Edit$. Characters specifies a maximum number of allowable characters for input. This is extremely useful in preventing Edit$ from destroying display contents."
    },
    "Edit": {
        "prefix": "Edit",
        "body": "Edit([DefaultValue],Characters)",
        "description": "Edit is Blitz's standard numeric input command. The same characteristics apply as those for Edit$ however Edit of course only accepts numeric input."
    },
    "Inkey$": {
        "prefix": "Inkey$",
        "body": "Inkey$[(Characters)]",
        "description": "Inkey$ is used to collect one or more characters from the current input channel. Current input channel may be selected using commands such as WindowInput, Filelnput or BitMapInput. Inkey$ MAY NOT be used from Defaultinput input channel as CLI does not pass input back to the program until the user hits return. Characters refers to the number of characters to collect. The default is one character."
    },
    "DefaultInput": {
        "prefix": "DefaultInput",
        "body": "DefaultInput",
        "description": "Defaultinput causes all future Edit$ and Inkey$ functions to receive their input from CLI window the Blitz program was run from. This is the default input channel used when a Blitz program is first run"
    },
    "DefaultOutput": {
        "prefix": "DefaultOutput",
        "body": "DefaultOutput",
        "description": "DefaultOutput cause all future Print statements to send their output to CLI window the Blitz program was run from. This is the default output channel used when a Blitz program is first run."
    },
    "FileRequest$": {
        "prefix": "FileRequest$",
        "body": "FileRequest$(Title$, Pathname$, Filename$)",
        "description": "FileRequest$ function will open up a standard Amiga-style file requester on currently used screen. Program flow will halt until user either selects a file, or hits requester's 'Cancel' button. If a file was selected, FileRequest$ will return the full file name as a string. If 'Cancel' was selected, FileRequest$ will return a null (empty) string. Title$ may be any string expression to be used as a title for the file requester. Pathname$ MUST be a string variable with a MaxLen of at least 160. Filename$ MUST be a string variable with a MaxLen of at least 64."
    },
    "PopInput": {
        "prefix": "PopInput",
        "body": "PopInput",
        "description": "After input has been re-directed (eg using WindowInput/Filelnput), Popinput may be used to return the channel to it's previous condition."
    },
    "PopOutput": {
        "prefix": "PopOutput",
        "body": "PopOutput",
        "description": "After output has been re-directed (eg using WindowOutput/FileOutput), PopOutput may be used to return the channel to it's previous condition."
    },
    "JoyX": {
        "prefix": "JoyX",
        "body": "JoyX(Port)",
        "description": "Joyx will return the left/right status of a joystick plugged into the specified port. Port must be either 0 or 1, 0 being the port the mouse is normally plugged into. If the joystick is held to the left, Joyx will return -1. If the joystick is held to the right, Joyx will return 1. If the joystick is held neither left or right, Joyx will return 0."
    },
    "JoyY": {
        "prefix": "JoyY",
        "body": "JoyY(Port)",
        "description": "Joyy will return the up/down status of a joystick plugged into the specified port. Port must be either 0 or 1, 0 being the port the mouse is normally plugged into. If the joystick is held upwards, Joyy will return -1. If the joystick is held downwrads, Joyy will return 1. If the joystick is held neither upwards or downwards, Joyy will return 0."
    },
    "JoyR": {
        "prefix": "JoyR",
        "body": "JoyR(Port)",
        "description": "Joyr may be used to determine the rotational direction of a joystick plugged into the specified port. Port must be either 0 or 1, port 0 being the port the mouse is normally plugged into. Joyr returns a value from 0 through 8 based on the following table:"
    },
    "JoyB": {
        "prefix": "JoyB",
        "body": "JoyB(Port)",
        "description": "Joyb read button status of the device plugged into specified port. Port must be either 0 or 1, 0 being the port where mouse is normally plugged into. If left button is pressed, Joyb will return 1. If right button is pressed, Joyb will return 2. If both buttons are pressed, Joyb will return 3. If no buttons are pressed, Joyb will return 0."
    },
    "GameB": {
        "prefix": "GameB",
        "body": [
            "CD32_Buttons = GameB(Port)",
            "CD32_Play = CD32_Buttons & 1 = 1",
            "CD32_Reverse = CD32_Buttons & 2 = 2",
            "CD32_Forward = CD32_Buttons & 4 = 4",
            "CD32_Green = CD32_Buttons & 8 = 8",
            "CD32_Yellow = CD32_Buttons & 16 = 16",
            "CD32_Red = CD32_Buttons & 32 = 32",
            "CD32_Blue = CD32_Buttons & 64 = 64"
        ],
        "description": "GameB returns the button states of CD32 style game controllers. The values of all buttons pressed are added together to make up the value returned by GameB. To check a certain button is down a logical AND should be performed, buttonvalue AND returnvalue will evaluate to 0 if the button is not held down."
    },
    "OpenFile": {
        "prefix": "OpenFile",
        "body": [
            "if OpenFile(File#,Filename$)",
            "\t;Do your file handling here.",
            "\tCloseFile File#",
            "else",
            "\t;The file was not successfully opened. Do your error handling here.",
            "endif"
        ],
        "description": "OpenFile attempts to open the file specified by Filename$. If file was successfully opened, OpenFile will return true (-1), otherwise, OpenFile will return false (0). Files opened using OpenFile may be both written to and read from. If the file specified by Filename$ did not already exist before the file was opened, it will be created by OpenFile. Files opened with OpenFile are intended for use by the random access file commands, although it is quite legal to use these files in a sequential manner."
    },
    "ReadFile": {
        "prefix": "ReadFile",
        "body": [
            "if ReadFile(File#,Filename$)",
            "\t;Do your file handling here.",
            "\tCloseFile File#",
            "else",
            "\t;The file was not successfully opened. Do your error handling here.",
            "endif"
        ],
        "description": "ReadFile opens an already existing file specified by Filename$ for sequential reading. If the specified file was successfully opened, ReadFile will return true (-1), otherwise ReadFile will return false (0). Once a file is open using ReadFile, FileInput may be used to read information from it."
    },
    "WriteFile": {
        "prefix": "WriteFile",
        "body": [
            "if WriteFile(File#,Filename$)",
            "\t;Do your file handling here.",
            "\tCloseFile File#",
            "else",
            "\t;The file was not successfully opened. Do your error handling here.",
            "endif"
        ],
        "description": "WriteFile creates a new file, specified by Filename$ for the purpose of sequential file writing. If the file was successfully opened, WriteFile will return true (-1), otherwise WriteFile will return false (0). A file opened using WriteFile may be written to by using the FileOutput command."
    },
    "CloseFile": {
        "prefix": "CloseFile",
        "body": "CloseFile File#",
        "description": "CloseFile is used to close a file opened using one of the file open functions (FileOpen, ReadFile, WriteFile). This should be done to all files when they are no longer required."
    },
    "Fields": {
        "prefix": "Fields",
        "body": "Fields File#, Var[, Var...]",
        "description": "Fields set up fields of a random access file record. Once Fields is executed, Get and Put are used to read and write information to and from the file. The Var parameters specify a list of variables you wish to be either read from or written to the file. When a Put is executed the values held in these variables will be transferred to the file. When a Get is executed these variables will take on values read from the file. Any string variables in the variable list MUST have been initialized to contain a maximum number of characters. This is done using the MaxLen command. These string variables must NEVER grow to be longer than their defined maximum length."    
    },      
    "Put": {
        "prefix": "Put",
        "body": "Put File#,Record",
        "description": "Put is used to transfer the values contained in a Fields variable list to a particular record in a random access file. When using Put to increase size of a random access file, you may only add to the immediate end of file. For example, if you have a random access file with 5 records in it, it is illegal to put record number 7 to the file until record number 6 has been created. "
     },
     "Get": {
        "prefix": "Get",
        "body": "Get File#,Record",
        "description": "Get is to transfer information from a particular record of a random access file into a variable list set up by Fields command. Only records which also exist may be'got'. "
     },            
     "FileOutput": {
        "prefix": "FileOutput",
        "body": "FileOutput File#",
        "description": "FileOutput causes output of all subsequent Print and NPrint commands to be sent to the specified sequential file. When the file is later closed, Print statements should be returned to an appropriate output channel (eg: DefaultOutput or WindowOutput). Filelnput File# FileInput command causes all subsequent Edit, Edit$ and Inkey$ commands to receive their input from the specified file. When file is later closed, input should be redirected to an appropriate channel (eg: DefaultInput or WindowInput). "
     },     
     "FileSeek": {
        "prefix": "FileSeek",
        "body": "FileSeek File#,Position",
        "description": "FileSeek allows you to move to a particular point in the specified file. The first piece of data in a file is at position 0, the second at position 1 and so on. Position must not be set to a value greater than the length of the file. Used in conjunction with OpenFile and Lof, FileSeek may be used to 'append'to a file. "
     },
     "Lof": {
        "prefix": "Lof",
        "body": "Lof(File#)",
        "description": "Lof will return the length, in bytes, of the specified file. "
     },
     "Eof": {
        "prefix": "Eof",
        "body": "Eof (File#)",
        "description": "Eof function allows you to determine if you are currently positioned at the end of the specified file. If so, Eof will return true (-1), otherwise Eof will return false (0). If you are at the end of a file, any further writing to the file will increase it's length, while any further reading from the file will cause an error. "
     },   
     "Loc": {
        "prefix": "Loc",
        "body": "Loc (File#)",
        "description": "Loc may be used to determine your current position in the specified file. When a file is first opened, you will be at position 0 in the file DosBuffLen Bytes All Blitz file handling is done through the use of special buffering routines. This is done to increase the speed of file handling, especially in the case of sequential files. Initially, each file opened is allocated a 2048 byte buffer. However, if memory is tight this buffer size may be lowered using the DosBuffLen command. "
     },  
     "KillFile": {
        "prefix": "KillFile",
        "body": "KillFile Filename$",
        "description": "KillFile command will simply attempt to delete the specified file. No error will be returned if the file could not be deleted. CatchDosErrs Whenever you are executing AmigaDos I/O (for example, reading or writing a file), there is always the possibility of something going wrong (for example, disk not inserted... read/write error etc.). Normally, when such problems occur, AmigaDos displays a suitable requester on the WorkBench window. However, by executing CatchDosErrs you can force such requesters to open on a Blitz window. The window you wish dos error requesters to open on should be the currently used window at the time CatchDosErrs is executed. "
     }, 
     "ReadMem": {
        "prefix": "ReadMem",
        "body": "ReadMem File#,Address,Length",
        "description": "ReadMem allows to read a number of bytes, determined by Length, into an absoulte memory location, determined by Address, from an open file specified by File#. Be careful using ReadMem, as writing to absolute memory may have serious consequences if you don't known what you're doing! "
     },
     "WriteMem": {
        "prefix": "WriteMem",
        "body": "WriteMem File#,Address,Length",
        "description": "WriteMem allows you to write a number of bytes, determined by Length, from an absolute memory location, determined by Address to an open file specified by File#. "
     },                        
     "Exists": {
        "prefix": "Exists",
        "body": "Exists (FileName$)",
        "description": "Exists actually returns the length of the file, unlike Lof() Exists() is for files that have not already been opened. If 0 the file either does not exist or is empty or is perhaps not a file at all! Hmmm, anyway the following poke turns off the \"Please Insert Volume Blah:\" requester so you can use Exists to wait for disk changes: Poke.l Peek.l(Peek.l(4)+276)+184,-1 ILBMlnfo Filename$ ILBMInfo examines an ILBM file. Once ILBMInfo has been executed. ILBMWidth, ILBMHeight and ILBMDepth examines properties of the image contained in file "
     },
     "ILBMWidth": {
        "prefix": "ILBMWidth",
        "body": "ILBMWidth",
        "description": "ILBMWidth will return the width (pixels) of an ILBM image examined with ILBMInfo. "
     },
     "ILBMHeight": {
        "prefix": "ILBMHeight",
        "body": "ILBMHeight",
        "description": "ILBMHeight will return the height (pixels) of an ILBM image examined with ILBMInfo. "
     },
     "ILBMDepth": {
        "prefix": "ILBMDepth",
        "body": "ILBMDepth",
        "description": "ILBMDepth will return the depth (bitplanes) of ILBM image examined with ILBMInfo. "
     },
     "ILBMViewMode": {
        "prefix": "ILBMViewMode",
        "body": "ILBMViewMode",
        "description": "ILBMViewMode returns the viewmode of the file that was processed by ILBMInfo. This is useful for opening a screen in the right mode before using LoadScreen etc.  Different values of ViewMode are as follows (add/or them for different combinations): Mode Value HiRes 32768 Ham 2048 HalfBrite 128 Interlace 4 LoRes 0 "
     }   
}